<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ATCoder ABC 001</title>
    <link href="/2021/11/06/ATCoder-ABC-001/"/>
    <url>/2021/11/06/ATCoder-ABC-001/</url>
    
    <content type="html"><![CDATA[<h1 id="ATCoder-ABC-001"><a href="#ATCoder-ABC-001" class="headerlink" title="ATCoder ABC 001"></a>ATCoder ABC 001</h1><p><a href="https://atcoder.jp/contests/abc001/tasks">题目链接</a></p><h2 id="A-题"><a href="#A-题" class="headerlink" title="A 题"></a>A 题</h2><p>太简单了，不放代码了。</p><h2 id="B-题"><a href="#B-题" class="headerlink" title="B 题"></a>B 题</h2><p>其实，就是模拟，只是需要注意边界问题，是一个左开右闭的区间。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> m;<br><br>    cin &gt;&gt; m;<br>    <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>)<br>        cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (m &gt; <span class="hljs-number">0</span> &amp;&amp; m &lt;= <span class="hljs-number">5000</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (m &lt; <span class="hljs-number">1000</span>)<br>            cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; (<span class="hljs-number">10</span> * m) / <span class="hljs-number">1000</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span><br>            cout &lt;&lt; (<span class="hljs-number">10</span> * m) / <span class="hljs-number">1000</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (m &gt; <span class="hljs-number">5000</span> &amp;&amp; m &lt;= <span class="hljs-number">30000</span>)<br>        cout &lt;&lt; m / <span class="hljs-number">1000</span> + <span class="hljs-number">50</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (m &gt; <span class="hljs-number">30000</span> &amp;&amp; m &lt;= <span class="hljs-number">70000</span>)<br>        cout &lt;&lt; (m / <span class="hljs-number">1000</span> - <span class="hljs-number">30</span>) / <span class="hljs-number">5</span> + <span class="hljs-number">80</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; <span class="hljs-number">89</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="C-题"><a href="#C-题" class="headerlink" title="C 题"></a>C 题</h2><p>同样是模拟，只是 <code>else if</code>  的数量有点多，注意边界，同上。</p><p>这道题目需要求一个保留两位小数的浮点数，所以需要自己手写函数 <code>Around</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">Around</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x,<span class="hljs-keyword">double</span> k)</span></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">floor</span>(<span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>,k)*x+<span class="hljs-number">0.5</span>) / <span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>,k);<br><span class="hljs-comment">// 保留两位小数</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>string s;<br><span class="hljs-keyword">int</span> cmp,meter;<span class="hljs-keyword">double</span> speed,sid;<br>cin&gt;&gt;sid&gt;&gt;meter;<br>speed = meter / <span class="hljs-number">60.0</span>;<br>speed = <span class="hljs-built_in">Around</span>(speed,<span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span>(sid &gt;= <span class="hljs-number">112.5</span> &amp;&amp; sid &lt;= <span class="hljs-number">337.5</span>)s = <span class="hljs-string">&quot;NNE&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sid &gt;= <span class="hljs-number">337.5</span> &amp;&amp; sid &lt; <span class="hljs-number">562.5</span>)s = <span class="hljs-string">&quot;NE&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sid &gt;= <span class="hljs-number">562.5</span> &amp;&amp; sid &lt; <span class="hljs-number">787.5</span>)s = <span class="hljs-string">&quot;ENE&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sid &gt;= <span class="hljs-number">787.5</span> &amp;&amp; sid &lt; <span class="hljs-number">1012.5</span>)s = <span class="hljs-string">&quot;E&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sid &gt;= <span class="hljs-number">1012.5</span> &amp;&amp; sid &lt; <span class="hljs-number">1237.5</span>)s = <span class="hljs-string">&quot;ESE&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sid &gt;= <span class="hljs-number">1237.5</span> &amp;&amp; sid &lt; <span class="hljs-number">1462.5</span>)s = <span class="hljs-string">&quot;SE&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sid &gt;= <span class="hljs-number">1462.5</span> &amp;&amp; sid &lt; <span class="hljs-number">1687.5</span>)s = <span class="hljs-string">&quot;SSE&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sid &gt;= <span class="hljs-number">1687.5</span> &amp;&amp; sid &lt; <span class="hljs-number">1912.5</span>)s = <span class="hljs-string">&quot;S&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sid &gt;= <span class="hljs-number">1912.5</span> &amp;&amp; sid &lt; <span class="hljs-number">2137.5</span>)s = <span class="hljs-string">&quot;SSW&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sid &gt;= <span class="hljs-number">2137.5</span> &amp;&amp; sid &lt; <span class="hljs-number">2362.5</span>)s = <span class="hljs-string">&quot;SW&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sid &gt;= <span class="hljs-number">2362.5</span> &amp;&amp; sid &lt; <span class="hljs-number">2587.5</span>)s = <span class="hljs-string">&quot;WSW&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sid &gt;= <span class="hljs-number">2587.5</span> &amp;&amp; sid &lt; <span class="hljs-number">2812.5</span>)s = <span class="hljs-string">&quot;W&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sid &gt;= <span class="hljs-number">2812.5</span> &amp;&amp; sid &lt; <span class="hljs-number">3037.5</span>)s = <span class="hljs-string">&quot;WNW&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sid &gt;= <span class="hljs-number">3037.5</span> &amp;&amp; sid &lt; <span class="hljs-number">3262.5</span>)s = <span class="hljs-string">&quot;NW&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sid &gt;= <span class="hljs-number">3262.5</span> &amp;&amp; sid &lt; <span class="hljs-number">3487.5</span>)s = <span class="hljs-string">&quot;NNW&quot;</span>;<br><span class="hljs-keyword">else</span>s = <span class="hljs-string">&quot;N&quot;</span>;<br><br><span class="hljs-keyword">if</span>(speed &gt;= <span class="hljs-number">0.0</span> &amp;&amp; speed &lt;= <span class="hljs-number">0.2</span>)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;C 0\n&quot;</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(speed &gt;= <span class="hljs-number">0.3</span> &amp;&amp; speed &lt;= <span class="hljs-number">1.5</span>)cmp = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(speed &gt;= <span class="hljs-number">1.6</span> &amp;&amp; speed &lt;= <span class="hljs-number">3.3</span>)cmp = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(speed &gt;= <span class="hljs-number">3.4</span> &amp;&amp; speed &lt;= <span class="hljs-number">5.4</span>)cmp = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(speed &gt;= <span class="hljs-number">5.5</span> &amp;&amp; speed &lt;= <span class="hljs-number">7.9</span>)cmp = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(speed &gt;= <span class="hljs-number">8.0</span> &amp;&amp; speed &lt;= <span class="hljs-number">10.7</span>)cmp = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(speed &gt;= <span class="hljs-number">10.8</span> &amp;&amp; speed &lt;= <span class="hljs-number">13.8</span>)cmp = <span class="hljs-number">6</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(speed &gt;= <span class="hljs-number">13.9</span> &amp;&amp; speed &lt;= <span class="hljs-number">17.1</span>)cmp = <span class="hljs-number">7</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(speed &gt;= <span class="hljs-number">17.2</span> &amp;&amp; speed &lt;= <span class="hljs-number">20.7</span>)cmp = <span class="hljs-number">8</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(speed &gt;= <span class="hljs-number">20.8</span> &amp;&amp; speed &lt;= <span class="hljs-number">24.4</span>)cmp = <span class="hljs-number">9</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(speed &gt;= <span class="hljs-number">24.5</span> &amp;&amp; speed &lt;= <span class="hljs-number">28.4</span>)cmp = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(speed &gt;= <span class="hljs-number">28.5</span> &amp;&amp; speed &lt;= <span class="hljs-number">32.6</span>)cmp = <span class="hljs-number">11</span>;<br><span class="hljs-keyword">else</span>cmp = <span class="hljs-number">12</span>;<br><br><br>cout&lt;&lt;s&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;cmp&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="D-题"><a href="#D-题" class="headerlink" title="D 题"></a>D 题</h2><p>比较简单的思维题。</p><p>输入时，注意时间为 5 分钟为增量舍入时间，观察题目发现时间总是从 $0000 \Rightarrow 9999$。所以可以想到开一个桶，第 $i$ 个桶表示第 $i$ 个时间是否有雨。最后重新遍历一次桶，记录下开始和结束的节点并输入。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">110000</span>;<br><span class="hljs-keyword">int</span> g[maxn];<br><span class="hljs-keyword">int</span> t;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;t;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=t;i++)&#123;<br><span class="hljs-keyword">int</span> x,y;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d-%d&quot;</span>,&amp;x,&amp;y);<br>x -= (x%<span class="hljs-number">5</span>);y += (<span class="hljs-number">5</span> - y%<span class="hljs-number">5</span>) % <span class="hljs-number">5</span>;<br><span class="hljs-comment">// cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl;</span><br><span class="hljs-keyword">if</span>(y%<span class="hljs-number">100</span>&gt;=<span class="hljs-number">60</span>)&#123;<br>y+=<span class="hljs-number">100</span>;<br>y-=<span class="hljs-number">60</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=x;j&lt;y;j++)g[j] ++;<br>&#125;<br><br><span class="hljs-keyword">int</span> on=<span class="hljs-number">0</span>,be=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">110000</span>;i++)&#123;<br><span class="hljs-keyword">if</span>(g[i])&#123;<br><span class="hljs-keyword">if</span>(!on)be=i;<br>on=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(on)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%04d-%04d\n&quot;</span>,be,i);<br>on=<span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ATCoder</tag>
      
      <tag>简单题</tag>
      
      <tag>模拟</tag>
      
      <tag>思维题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2021/10/06/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2021/10/06/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p><img src="https://z3.ax1x.com/2021/10/06/4x2h9K.png" alt="并查集"></p><p>并查集是一种树形的数据结构，可以很高效的解决一些问题。</p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>有三个操作：</p><ul><li>初始化</li><li>查找</li><li>合并</li></ul><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>初始时，每个点都是自己的父亲。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> fa[maxn];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++)<br>    fa[i] = i;<br></code></pre></div></td></tr></table></figure><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p><img src="https://z3.ax1x.com/2021/10/06/4xWYiq.png" alt=""></p><p>上图中，想要找 $5$ 的祖先，先通过 $2-5$ 这条边找到 $2$ ，通过同样的办法找到祖先 $1$，$1$ 没有祖先就得到答案了。<br>就像上面一样递归找到每个点的祖先，在返回答案。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">if</span>(x == fa[x])<span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">else</span><span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(fa[x]);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>显而易见，就是将两个集合合并。</p><p><img src="https://z3.ax1x.com/2021/10/06/4zwqgA.png" alt="union"></p><p>挺简单的，就直接上代码吧：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<br><span class="hljs-keyword">int</span> u = <span class="hljs-built_in">find</span>(x),v = <span class="hljs-built_in">find</span>(v);<br>    fa[u] = v;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>设操作次数为 $m$，平均时间复杂度为 $\mathcal{O}(m \log n)$，最坏时间复杂度为 $\mathcal{O}(mn)$。</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>在上面的操作中还是不够快，所以我们想办法优化。</p><h3 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h3><p>如果一个关系像一条链（如下图）一样，那么查找最下面的数的祖先的时间复杂度得退化到 $\mathcal{O}(n)$ 。</p><p><img src="https://z3.ax1x.com/2021/10/06/4z0LiF.png" alt="chain"></p><p>这样一层一层找太浪费时间，直接当祖先的儿子，问一次就可以出结果了。甚至祖先是谁都无所谓，只要这个人可以代表我们家族就能得到想要的效果。<strong>把在路径上的每个节点都直接连接到根上</strong>。</p><p><em>代码</em>：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">return</span> fa[x] == x ? x : fa[x] = <span class="hljs-built_in">find</span>(fa[x]);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="启发式合并"><a href="#启发式合并" class="headerlink" title="启发式合并"></a>启发式合并</h3><p>查找都优化了，那合并总不能不优化吧。</p><p>我们思考一个问题：如果一个点与一个含有 $100$ 个点的集合合并，是一个点合并到 $100$ 个点的集合快？还是 $100$ 个点合并到一个点快？答案是显然的。<br>在题目中我们通常维护 点数 或 深度 来作为估价函数来合并</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<br><span class="hljs-keyword">int</span> u = <span class="hljs-built_in">find</span>(x),v = <span class="hljs-built_in">find</span>(y);<br>    <span class="hljs-keyword">if</span>(u == v) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span>(sz[u] &gt; sz[v])<br>        <span class="hljs-built_in">swap</span>(u，v);<br>    fa[u] = v;<br>    sz[v] += sz[u];<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="优化后的时间复杂度"><a href="#优化后的时间复杂度" class="headerlink" title="优化后的时间复杂度"></a>优化后的时间复杂度</h3><ul><li>只使用路径压缩的平均时间复杂度为 $\mathcal{O}(m \alpha(n))$，最坏时间复杂度为 $\mathcal{O}(m \log n)$</li><li>只使用启发式合并的平均时间复杂度为 $\mathcal{O}(m \log n)$，最坏时间复杂度为 $\mathcal{O}(m \log n)$。</li><li>路径压缩 + 启发式合并的平均时间复杂度为 $\mathcal{O}(m \alpha(n))$，最坏时间复杂度为 $\mathcal{O}(m \alpha(n))$。</li></ul><p>这里 $\alpha(n)$ 表示阿克曼函数的反函数增长很慢，可以认为是常数(<a href="https://oi-wiki.org/ds/dsu/#_7">具体在这</a>)。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="带权并查集"><a href="#带权并查集" class="headerlink" title="带权并查集"></a>带权并查集</h3><p>我们可以在并查集上维护一些东西，比如元素和，元素个数。</p><p>比如说<a href="https://www.luogu.com.cn/problem/UVA11987">Almost Union-Find</a>这道题。它就是在并查集上维护一个元素和与元素个数，唯一不同的是这道题要一个虚点并查集，防止在第二个操作中下面的元素一起移动。</p><p>核心代码：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 初始化</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br> fa[i] = n+i;<br>        <br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n+<span class="hljs-number">1</span>;i&lt;=n+n;i++)<br>fa[i] = i,sz[i] = <span class="hljs-number">1</span>,sum[i] = i-n;<br><br><span class="hljs-comment">// 第二个操作，仅仅将一个节点移动到另一个集合上。</span><br><br><span class="hljs-keyword">int</span> u = <span class="hljs-built_in">find</span>(x),v = <span class="hljs-built_in">find</span>(y);<br><span class="hljs-keyword">if</span>(u != v)&#123;<br>fa[x] = v;<br>sz[u] --;sz[v] ++;<br>sum[u] -= x;sum[v] += x;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并查集</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵</title>
    <link href="/2021/09/18/%E7%9F%A9%E9%98%B5/"/>
    <url>/2021/09/18/%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在数学中，矩阵（Matrix）是一个按照长方阵列排列的复数或实数集合。</p><p>就像下面一样：</p><script type="math/tex; mode=display">\begin{bmatrix}    1&2&3\\1&2&3\end{bmatrix}</script><p>特别的，主对角线上为 1，其余位置为 0 的叫做单位矩阵 $I$：</p><script type="math/tex; mode=display">\begin{bmatrix}    1&0&\cdots&0\\    \vdots&1&\ddots&0\\    0&0&\dots&1\\\end{bmatrix}</script><h2 id="矩阵的运算"><a href="#矩阵的运算" class="headerlink" title="矩阵的运算"></a>矩阵的运算</h2><p>矩阵的加减法是逐个元素进行的。</p><h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h3><p>矩阵相乘只有在第一个矩阵的列数和第二个矩阵的行数相同时才有意义。</p><p>设 $P$ 为 $M \times N$ 的矩阵，$Q$ 是 $N \times Q$ 的矩阵，$C$ 矩阵为 $C = PQ$，则 $C$ 矩阵上 $i$ 行 $j$ 列的元素为。</p><script type="math/tex; mode=display">c_{i,j} = \sum\limits_{k=1}^{M}P_{i,k}Q_{k,j}</script><p>没有看懂，没事，有一种<del>比较简单</del>的方法。</p><p>设 $A$ 矩阵为:</p><script type="math/tex; mode=display">\begin{bmatrix}    a&b\\    c&d\\\end{bmatrix}</script><p>设 $B$ 矩阵为:</p><script type="math/tex; mode=display">\begin{bmatrix}    e\\f\end{bmatrix}</script><p>所以 $A$ 与 $B$ 的乘积是：</p><script type="math/tex; mode=display">e\begin{bmatrix}    a\\c\end{bmatrix} + f\begin{bmatrix}    b\\d\end{bmatrix}</script><p>注意，<strong>矩阵乘法满足结合律，不满足一般的交换律</strong>。</p><p>给出一个封装好的矩阵乘法：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mat</span>&#123;</span><br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> c[N][N];<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unit</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-built_in">memset</span>(c,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(c));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)   c[i][i] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mat</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-built_in">memset</span>(c,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(c));&#125;<br><span class="hljs-keyword">inline</span> mat <span class="hljs-keyword">operator</span>*(<span class="hljs-keyword">const</span> mat &amp;M)&#123;<br>mat ans;<br><span class="hljs-built_in">memset</span>(ans.c,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(ans.c);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)<br>ans.c[i][j] += (c[i][k] * M.c[k][j]) % P,ans.c[i][j] %= P;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>如果算一个矩阵的 $A^k$，可以使用快速幂来加速到 $\mathcal{O}(n^3 \log k)$。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 快速幂</span><br><span class="hljs-function">mat <span class="hljs-title">qpow</span><span class="hljs-params">(mat x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<br>    mat ans.<span class="hljs-built_in">unit</span>();<br>    <span class="hljs-keyword">while</span>(y &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">if</span>(y % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)<br>            ans = ans * x;<br>        y = y / <span class="hljs-number">2</span>;<br>        x = x * x;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="矩阵的应用"><a href="#矩阵的应用" class="headerlink" title="矩阵的应用"></a>矩阵的应用</h2><h3 id="快速求斐波拉契数列"><a href="#快速求斐波拉契数列" class="headerlink" title="快速求斐波拉契数列"></a>快速求斐波拉契数列</h3><p>斐波拉契数列形如：</p><script type="math/tex; mode=display">F_1 = F_2 = 1,F_i = F_{i-1} + F_{i-2}  (i  \geq 3)</script><p>当然可以使用递推的方法来求，时间复杂度 $\mathcal{O}(n)$ ，还挺快。<br>但是遇到<a href="https://www.luogu.com.cn/problem/P1962">这道题目</a>就不行了，$2^{63}$ 绝对会 TLE，所以可以用矩阵加速递推。</p><p>我们可以设 <script type="math/tex">f(n) = \begin{bmatrix}F_{n} & F_{n-1}\end{bmatrix}</script> ，我们希望可以从 $f(n-1)$ 推出它。</p><p>正好我们之前学了矩阵的乘法，所以我们可以尝试设一个矩阵 $\text{base}$ ，使得 $f(n) = \text{base} \times f(n-1)$，也就是：</p><script type="math/tex; mode=display">\begin{bmatrix} F_i & F_{i-1}\end{bmatrix} = \text{base} \times \begin{bmatrix}F_{i-1} & F_{i-2}\end{bmatrix}</script><p>因为前后都是 $1 \times 2$ 的矩阵，所以可以知道 $\text{base}$ 矩阵是 $2 \times 2$ 的矩阵。</p><p>所以 $\text{base} = \begin{bmatrix}<br>a &amp; b \<br>c &amp; d \<br>\end{bmatrix}$</p><p>所以等式转化为：</p><script type="math/tex; mode=display">\begin{bmatrix} F_i & F_{i-1}\end{bmatrix} = F_{i-1} \times \begin{bmatrix}a & b\end{bmatrix} + F_{i-2} \times \begin{bmatrix}c & d\end{bmatrix}</script><script type="math/tex; mode=display">\begin{bmatrix} F_i & F_{i-1}\end{bmatrix} = \begin{bmatrix}a F_{i-1} + c F_{i-2}  & b F_{i-1} + d F_{i-2}\end{bmatrix}</script><p>又因为 <script type="math/tex">F_i = F_{i-1} + F_{i-2}</script>，所以 <script type="math/tex">a = 1,c = 1,b = 1,d = 0</script>。</p><p>综上所述， <script type="math/tex">\text{base} = \begin{bmatrix} 1 & 1 \\1 & 0\end{bmatrix}</script>。</p><p>那么因为初始项为 $F_1,F_2$。所以 $F_n = \begin{bmatrix} F_1 &amp; F_2 \end{bmatrix} \times \text{base}^{n-2}$</p><p>好好品品。</p><p>$\text{base}^{n-2}$ 矩阵可以通过上面的快速幂来求，所以时间复杂度为 $\mathcal{O}(\log n)$。</p><p>这题核心代码：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mat</span>&#123;</span><br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> c[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>];<br><span class="hljs-built_in">mat</span>() &#123;<span class="hljs-built_in">memset</span>(c,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(c));&#125;<br><span class="hljs-keyword">inline</span> mat <span class="hljs-keyword">operator</span>*(<span class="hljs-keyword">const</span> mat&amp; M)&#123;<br>mat res;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2</span>;i++)<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">2</span>;j++)<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;k&lt;=<span class="hljs-number">2</span>;k++)<br>res.c[i][j] = (res.c[i][j] + c[i][k]*M.c[k][j]) % mod;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br>&#125;;<br><br>mat base,ans;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>base.c[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = base.c[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = base.c[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>ans.c[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = ans.c[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">qpow</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> y)</span></span>&#123;<br><span class="hljs-keyword">while</span>(y &gt; <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">if</span>(y % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)<br>ans = ans * base;<br>y = y / <span class="hljs-number">2</span>;<br>base = base * base;<br>&#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>其实矩阵可以干事情的很多，就写这么多吧。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习线段树总结</title>
    <link href="/2021/08/22/%E5%AD%A6%E4%B9%A0%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%80%BB%E7%BB%93/"/>
    <url>/2021/08/22/%E5%AD%A6%E4%B9%A0%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>这几天在复习 qbxt 的知识，学到了线段树，就来总结一下。</p><h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><p><img src="https://z3.ax1x.com/2021/08/17/f4sLWR.png" alt=""></p><p>上面这张图显然是线段树，线段树就是一个处理区间的一个数据结构，将整个线段划分成一个树的结构，将长度不是 1 的段划分成两个子区间来求解，通过合并两个区间的信息来求解，这也是一个高效的数据结构。</p><p>总体时间复杂度为 $O(\log n)$  </p><ul><li>适用范围：区间的最小值或最大值，区间的修改，区间求和</li></ul><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>在所有操作开始之前，可以观察到一个根节点为 $p$ 的左儿子为 $p^2$ ，右儿子为  $p^2+1$</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ls</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<span class="hljs-keyword">return</span> x&lt;&lt;<span class="hljs-number">1</span>;&#125;   <span class="hljs-comment">// 左儿子 left sons</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<span class="hljs-keyword">return</span> (x&lt;&lt;<span class="hljs-number">1</span>)+<span class="hljs-number">1</span>;&#125;   <span class="hljs-comment">// 右儿子 right sons</span><br></code></pre></div></td></tr></table></figure><h3 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h3><p>我们可以想到像树上 DFS 一样，可以一直访问儿子节点，直到儿子节点长度为 1  ，我们可以通过数据上的值去更改子节点的值，再有子节点来合并（更新）父节点的值。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">built</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> p)</span></span>&#123;<br>    <span class="hljs-comment">// 建树 [l,r] 为当前的区间，p 为当前的节点编号</span><br>lazy[p] = <span class="hljs-number">1</span>;<span class="hljs-comment">// lazy_tag 后面会讲到</span><br><span class="hljs-keyword">if</span>(l == r)&#123;<span class="hljs-comment">// 如果 长度为 1 </span><br>d[p] = a[l];<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">int</span> mid = l+(r-l)/<span class="hljs-number">2</span>;<span class="hljs-comment">// 递归求解</span><br><span class="hljs-built_in">built</span>(l,mid,<span class="hljs-built_in">ls</span>(p));<span class="hljs-built_in">built</span>(mid+<span class="hljs-number">1</span>,r,<span class="hljs-built_in">rs</span>(p));<br>d[p] = d[<span class="hljs-built_in">ls</span>(p)] + d[<span class="hljs-built_in">rs</span>(p)] ;  <span class="hljs-comment">// 由儿子更新父亲，合并</span><br>    <span class="hljs-comment">// 如果是求最大值，改成 d[p] = max(d[ls(p)],d[rs(p)]);最小值同样 </span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h3><p>首先，我们可以想到还是像建树一样递归求解，如果这个区间在所要求的区间上了，直接返回，如果左儿子的子区间和原答案有交集，那么就递归到相应的节点上求解。那么思路就讲好了，代码怎么写呢？下面放上几张图就了解了</p><p>设所在区间为 $[l,r]$ , 查询区间为 $[s,t]$ 。</p><p><img src="https://z3.ax1x.com/2021/08/20/fj97CQ.jpg" alt="tree"></p><p>那么根据这张图可以很显然的推出所在区间在查询区间的判断方式：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(s &lt;= l &amp;&amp; r &lt;= t)<br></code></pre></div></td></tr></table></figure><p>设中间位置为 $mid = \dfrac{(l+r)}{2}$  。</p><p><img src="https://z3.ax1x.com/2021/08/20/fjiS1J.jpg" alt=""></p><p>可以很<del>简单</del>的看出，进入左儿子的条件是：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(mid &gt;= s)<br></code></pre></div></td></tr></table></figure><p>进入右儿子的条件是：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(mid &lt; t)<br></code></pre></div></td></tr></table></figure><p>综上，我们可以得出查询代码：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">LL <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> s,<span class="hljs-keyword">int</span> t,<span class="hljs-keyword">int</span> p)</span></span>&#123;<br><span class="hljs-comment">// l,r 为当前的, s,t 为询问的</span><br><span class="hljs-keyword">if</span>(l&gt;=s &amp;&amp; r &lt;= tt)<br><span class="hljs-keyword">return</span> d[p];<br><span class="hljs-keyword">int</span> mid = l+(r-l)/<span class="hljs-number">2</span>;<br><span class="hljs-built_in">pushdown</span>(p,l,r); <br>LL sum = <span class="hljs-number">0</span>; <br><span class="hljs-keyword">if</span>(mid &gt;= s)<br>sum += <span class="hljs-built_in">query</span>(l,mid,s,t,<span class="hljs-built_in">ls</span>(p));    <span class="hljs-comment">// 如果是求最大值，就改成</span><br><span class="hljs-comment">// sum = max(quert(l,mid,s,t,ls(p)),sum);     最小值同样</span><br><span class="hljs-keyword">if</span>(tt &gt; mid)<br>sum += <span class="hljs-built_in">query</span>(mid+<span class="hljs-number">1</span>,r,s,tt,<span class="hljs-built_in">rs</span>(p));<br><span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="单点修改"><a href="#单点修改" class="headerlink" title="单点修改"></a>单点修改</h3><p>在讲区间修改之前，我先来讲一下最基础的单点修改。单点修改也是递归找需要更改的点，然后再返回合并父节点的值</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> f,<span class="hljs-keyword">int</span> c,<span class="hljs-keyword">int</span> p)</span></span>&#123;<br><span class="hljs-comment">// [l,r] 当前 p 节点的范围，f 是修改的点的编号， c 是修改的值</span><br><span class="hljs-keyword">if</span>(l == r)&#123;<span class="hljs-comment">// 如果递归到所达到的点了</span><br>d[p] = c;<br><span class="hljs-comment">// 如果是加上 c ，改成</span><br><span class="hljs-comment">// d[p] += c;</span><br>        <span class="hljs-comment">// 减去同理</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">int</span> mid = l + (r-l)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(mid &gt;= f)<span class="hljs-comment">// 如果所要修改的点在左儿子上，进入左儿子</span><br><span class="hljs-built_in">update</span>(l,mid,f,c,<span class="hljs-built_in">ls</span>(p));<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">update</span>(mid+<span class="hljs-number">1</span>,r,f,c,<span class="hljs-built_in">rs</span>(p));<br>d[p] = d[<span class="hljs-built_in">ls</span>(p)] + d[<span class="hljs-built_in">rs</span>(p)];<br>    <span class="hljs-comment">// 如果是求最大值，就改成</span><br>    <span class="hljs-comment">// d[p] = max(d[ls(p)] + d[rs(p)]);</span><br>    <span class="hljs-comment">// 最小值同理</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="区间修改"><a href="#区间修改" class="headerlink" title="区间修改"></a>区间修改</h3><ul><li><p>懒标记</p><p>简单来说，就是通过<strong>延迟</strong>对节点信息的更改，从而减少可能不必要的操作次数。每次执行修改时，我们通过打标记的方法表明该节点对应的区间在某一次操作中被更改，但不更新该节点的子节点的信息。实质性的修改则在下一次访问带有标记的节点时才进行。</p><div class="hljs code-wrapper"><pre><code>                                                                                                                                                                ----- OI-Wiki</code></pre></div></li></ul><p>这段话<del>深刻的阐释了</del>懒标记的作用，如果不用懒标记时间复杂度将会达到 $\mathcal{O}(n \log n)$ 有点慢，这样一来时间复杂度为 $\mathcal{O}(\log n)$ 的。</p><p>听我这样一讲有点蒙先来看代码吧：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> s,<span class="hljs-keyword">int</span> tt,<span class="hljs-keyword">int</span> c,<span class="hljs-keyword">int</span> p)</span></span>&#123;<br><span class="hljs-comment">// [l,r] 为当前的, [s,t] 为询问的</span><br><span class="hljs-keyword">if</span>(l &gt;= s &amp;&amp; r &lt;= tt)&#123;<br>t[p] += (r-l+<span class="hljs-number">1</span>)*c;lazy[p] += c  <span class="hljs-comment">//懒标记;</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">int</span> mid = l+(r-l)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(lazy[p] &amp;&amp; l!=r)&#123; <span class="hljs-comment">// 懒标记的更新</span><br>t[<span class="hljs-built_in">ls</span>(p)] += (mid-l+<span class="hljs-number">1</span>)*lazy[p];t[<span class="hljs-built_in">rs</span>(p)] += (r-mid) * lazy[p];<br>lazy[<span class="hljs-built_in">ls</span>(p)] += lazy[p];lazy[<span class="hljs-built_in">rs</span>(p)] += lazy[p];<br>lazy[p] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(mid &gt;= s)<br><span class="hljs-built_in">update</span>(l,mid,s,tt,c,<span class="hljs-built_in">ls</span>(p));<br><span class="hljs-keyword">if</span>(tt &gt; mid)<br><span class="hljs-built_in">update</span>(mid+<span class="hljs-number">1</span>,r,s,tt,c,<span class="hljs-built_in">rs</span>(p));<br>t[p] = t[<span class="hljs-built_in">ls</span>(p)] + t[<span class="hljs-built_in">rs</span>(p)];<br>&#125;<br></code></pre></div></td></tr></table></figure><p>举个例子吧：</p><p><img src="https://z3.ax1x.com/2021/08/22/hpaTg0.png" alt="step1"></p><p>如果我想要更改 $[9,10]$ 的每个数加上 5，我们可以先直接在这个区间上改，并给它们打上标记。</p><p><img src="https://z3.ax1x.com/2021/08/22/hpdV5d.png" alt="step2"></p><p>虽然，子节点没有更新值，但当我们要查询这两个子节点的信息时，我们会利用标记修改这两个子节点的信息，使查询的结果依旧准确。</p><p>现在，来查询一下 $[9,9]$ 的值，当递归到 $[9,10]$ 时，因为懒标记不为 0 ，所以将该区间的子区间更新并清零。</p><p><img src="https://z3.ax1x.com/2021/08/22/hpduxP.png" alt="step3"></p><p>当然为了编写的简单性，修改懒标记可以写一个单独的函数 <code>pushdown</code> 。</p><p>带乘法的查询也同理，只是新加一个乘法懒标记而已</p><h3 id="带懒标记的查询"><a href="#带懒标记的查询" class="headerlink" title="带懒标记的查询"></a>带懒标记的查询</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">LL <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> s,<span class="hljs-keyword">int</span> tt,<span class="hljs-keyword">int</span> p)</span></span>&#123;<br><span class="hljs-comment">// l,r 为当前的, s,tt 为询问的</span><br><span class="hljs-keyword">if</span>(l&gt;=s &amp;&amp; r &lt;= tt)<br><span class="hljs-keyword">return</span> t[p];<br><span class="hljs-keyword">int</span> mid = l+(r-l)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(lazy[p])&#123;<br>t[<span class="hljs-built_in">ls</span>(p)] += lazy[p] * (mid-l+<span class="hljs-number">1</span>);t[<span class="hljs-built_in">rs</span>(p)] += lazy[p] * (r-mid);<br>lazy[<span class="hljs-built_in">ls</span>(p)] += lazy[p];lazy[<span class="hljs-built_in">rs</span>(p)] += lazy[p];<br>lazy[p] = <span class="hljs-number">0</span>;<br>&#125;<br>LL sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(mid &gt;= s)<br>sum += <span class="hljs-built_in">query</span>(l,mid,s,tt,<span class="hljs-built_in">ls</span>(p));<br>    <span class="hljs-comment">// 如果是求最大值，就改成</span><br>    <span class="hljs-comment">// sum = max(quert(l,mid,s,t,ls(p)),sum);     最小值同理</span><br><span class="hljs-keyword">if</span>(tt &gt; mid)<br>sum += <span class="hljs-built_in">query</span>(mid+<span class="hljs-number">1</span>,r,s,tt,<span class="hljs-built_in">rs</span>(p));<br><span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><p>基本上有了这些操作就可以写以下几道题目：</p><ul><li><p><a href="https://www.luogu.com.cn/problem/P3372">洛谷 P3372 【模板】线段树 1</a> </p><p>这道题是个纯模板题</p></li><li><p><a href="https://www.luogu.com.cn/problem/P3373">洛谷 P3373 【模板】线段树 2</a></p><p>这道题也差不多是个模板题，只是要注意：<strong>先乘后加</strong> 懒标记</p></li><li><p><a href="https://vjudge.net/problem/HDU-1166">HDU-1166 敌兵布阵</a></p><p>单点修改的模板</p></li><li><p><a href="https://vjudge.net/problem/HDU-1754">HDU-1754 I Hate It</a></p><p>单点修改，查询最大值的模板</p></li><li><p><a href="https://vjudge.net/problem/HDU-1394">HDU-1394 Minimum Inversion Number</a> </p><p>线段树解决逆序对问题</p></li><li><p><a href="https://vjudge.net/problem/POJ-3468">POJ-3468 A Simple Problem with Integers</a></p><p>区间修改的模板题</p></li></ul><p>模板题/好题未完待续 $\dots \dots$ </p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>线段树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVA1160题解</title>
    <link href="/2021/08/22/UVA1160%E9%A2%98%E8%A7%A3/"/>
    <url>/2021/08/22/UVA1160%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ul><li>并查集</li></ul><p>简单的查找（带路经压缩）:</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">return</span> x == fa[x] ? x : fa[x] = <span class="hljs-built_in">find</span>(fa[x]);<br>    <span class="hljs-comment">// fa[i] 为并查集的数组</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>查找（这里可以数据小完全不需要用启发式合并）：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<br><span class="hljs-keyword">int</span> f = <span class="hljs-built_in">find</span>(x),t = <span class="hljs-built_in">find</span>(y);<br>    fa[f] = t;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>查阅资料可知，只用路径压缩，不用启发式合并的平均时间复杂度为 $\mathcal{O}(\alpha (n))$ ，最坏时间复杂度为 $\mathcal{O}(m \log n)$ 。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先可以将每个元素看成点，化合物看成边，因为如果有超过 3 个物品互相形成化合物就会爆炸，所以会爆炸的条件可以看成两个是在同一祖先（在同一集合）中，（如果这两个点有一个祖先的话，合并就会有 3 个物品在一起的）。</p><p>每一次都将不在一个集合中两个数合并。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">int</span> fa[<span class="hljs-number">100010</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">return</span> x == fa[x] ? x : fa[x] = <span class="hljs-built_in">find</span>(fa[x]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> x,y;<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x) == <span class="hljs-number">1</span>)&#123;    \\ 注意输入<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">100010</span>;i++)fa[i] = i;<br><span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(x != <span class="hljs-number">-1</span>)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;y);<br><span class="hljs-keyword">int</span> f = <span class="hljs-built_in">find</span>(x),t = <span class="hljs-built_in">find</span>(y);<br><span class="hljs-keyword">if</span>(f == t)ans ++;<br><span class="hljs-keyword">else</span><br>fa[f] = t;    <span class="hljs-comment">// 如果不会爆炸，就合并</span><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>UVA</tag>
      
      <tag>并查集</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python实现爬取UVA题库的PDF</title>
    <link href="/2021/08/09/Python%E5%AE%9E%E7%8E%B0%E7%88%AC%E5%8F%96UVA%E9%A2%98%E5%BA%93%E7%9A%84PDF/"/>
    <url>/2021/08/09/Python%E5%AE%9E%E7%8E%B0%E7%88%AC%E5%8F%96UVA%E9%A2%98%E5%BA%93%E7%9A%84PDF/</url>
    
    <content type="html"><![CDATA[<p>我在一次看洛谷日报时了解到了有一个软件可以下载 UVA 的 PDF ， 我试了一下连接不上，可能是软件的作者太久没有更新了无法下载了，我便自己写了一个 Python ,可能有些不好的地方。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> urllib3<br><span class="hljs-keyword">import</span> time<br><br>url = <span class="hljs-string">&#x27;https://uva.onlinejudge.org/external/1/p&#x27;</span><br><br>urllib3.disable_warnings()<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">download</span>(<span class="hljs-params">name,url</span>):</span><br>    response = requests.get(url,verify=<span class="hljs-literal">False</span>)  <span class="hljs-comment"># 就是这个地方不能用异步，有没有大佬知道为什么</span><br>    <span class="hljs-built_in">print</span>(response)<br>    f = <span class="hljs-built_in">open</span>(name,<span class="hljs-string">&#x27;wb&#x27;</span>)<br>    f.write(response.content)<br>    f.close()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span> :<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-----------------------------------&quot;</span>)<br>        i = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入你所需要的 UVA 题号 ： &quot;</span>))<br>        time.sleep(<span class="hljs-number">3</span>)<br>        download(<span class="hljs-built_in">str</span>(i) + <span class="hljs-string">&#x27;.pdf&#x27;</span>,url + <span class="hljs-built_in">str</span>(i) + <span class="hljs-string">&#x27;.pdf&#x27;</span>)<br></code></pre></div></td></tr></table></figure><p>注 ： 还会根据我的需要不定时更新</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVA11426 GCD - Extreme (II)</title>
    <link href="/2021/07/28/UVA11426-GCD-Extreme-II/"/>
    <url>/2021/07/28/UVA11426-GCD-Extreme-II/</url>
    
    <content type="html"><![CDATA[<h1 id="UVA11426-GCD-Extreme-II"><a href="#UVA11426-GCD-Extreme-II" class="headerlink" title="UVA11426 GCD - Extreme (II)"></a>UVA11426 GCD - Extreme (II)</h1><p>这几天我看了 LRJ 的书看到了这一题，就把这道题写了，正好这道题挺不错的。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://uva.onlinejudge.org/external/114/p11424.pdf">题目PDF</a></p><h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><ul><li>定义： $\varphi(n)$ 为小于等于 $n$ 与 $n$ 互质的数的个数</li></ul><p>它有一些有趣的性质：</p><ul><li>$\varphi(n)$  是积性函数 ： 如果有 $\gcd(i,j) = 1$ 那么就有 $\varphi(i \times j) = \varphi(i) \times \varphi(j)$</li></ul><h3 id="如何求欧拉函数："><a href="#如何求欧拉函数：" class="headerlink" title="如何求欧拉函数："></a>如何求欧拉函数：</h3><p>用一个类似于筛法求素数的方法，时间复杂度相似于埃氏筛法 $\mathcal{O}(n\log \log n)$</p><p><strong>模板代码</strong>如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> phi[maxn];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">table</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt;= n;i ++)<br>        phi[i] = <span class="hljs-number">0</span>;<br>    phi[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;i &lt;= n;i ++)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i;j &lt;= n;j ++)&#123;<br>    <span class="hljs-keyword">if</span>(!phi[j])phi[j] = j;<br>    phi[j] = phi[j] / i * (i<span class="hljs-number">-1</span>);<br>    &#125;<br>   <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先，我们能想到暴力，每一次将每一个的 $\gcd$ 求出 ，最差时间复杂度为 $\mathcal{O}(n^2\log n )$ ，太慢，在这个数据目前无能为力，所以想办法优化。</p><p>设 <script type="math/tex">\large f(n) = \sum\limits_{i=1}^{n-1}\gcd(i,n)</script> ，</p><p>所以答案为  <script type="math/tex">\large S(n) = \sum\limits_{i=1}^{n} f(i)</script>。</p><p><del>易证</del> ，$\gcd(i,n)$ 的值都是 n 的约数，我们好好看看这个柿子有什么优化的地方</p><p>设 $\dfrac{x}{i}$ ，所以 $\gcd(\dfrac{x}{i},\dfrac{n}{i}) = 1$</p><p>$\therefore$  $\dfrac{x}{i}$ 与 $\dfrac{n}{i}$ 互质</p><p>所以小于等于 $\dfrac{n}{i}$ 的互质的 $\dfrac{x}{i}$ 一共有 $\varphi(\dfrac{n}{i})$  个</p><p>又 $\because$   $\gcd(i,n)$  $\leqslant n$ </p><p>$\therefore $   $\large f(n) = \sum\limits_{i\subset A} i \times \varphi(\dfrac{n}{i})$  $( A = n$ 的约数 $)$ </p><p>上面的柿子就是我们所需要的，时间复杂度与求欧拉筛法同阶。</p><p>代码 ：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">4000000</span>;<br><br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> phi[maxn],s[maxn],f[maxn];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">phi_c</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=maxn;i++)phi[i] = <span class="hljs-number">0</span>;<br>phi[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=maxn;i++)&#123;<br><span class="hljs-keyword">if</span>(!phi[i])<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i;j&lt;=maxn;j+=i)&#123;<br><span class="hljs-keyword">if</span>(!phi[j])<br>phi[j] = j;<br>phi[j] = phi[j] / i * (i<span class="hljs-number">-1</span>);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">phi_c</span>();<br><span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(f));<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=maxn;i++)<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i*<span class="hljs-number">2</span>;j&lt;=maxn;j+=i)<br>f[j] += i*phi[j/i];<br><br>s[<span class="hljs-number">2</span>] = f[<span class="hljs-number">2</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">3</span>;j&lt;=maxn;j++)<br>s[j] = s[j<span class="hljs-number">-1</span>] + f[j];<br><br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n) &amp;&amp; n)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,s[n]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
      <tag>筛法</tag>
      
      <tag>题解</tag>
      
      <tag>UVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组合数</title>
    <link href="/2021/07/05/%E7%BB%84%E5%90%88%E6%95%B0/"/>
    <url>/2021/07/05/%E7%BB%84%E5%90%88%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>这几天的竞赛期末考试中遇到了组合数的题目，就是 <a href="https://www.luogu.com.cn/problem/P2822">NOIP2016 组合数问题</a> 原题，正好现在数学学到了一点点排列组合，就来整理一下吧。</p><h2 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h2><p>就是从 $n$ 个不同元素中，抽取 $m$ 个元素的方案数。</p><p>组合数公式为：</p><script type="math/tex; mode=display">\dbinom{n}{m}= \dfrac{n!}{m! \times (n-m)!}</script><p>通过杨辉三角可得到递推公式：</p><p>$\dbinom{i}{j} = \dbinom{i-1}{j-1} + \dbinom{i-1}{j}$ </p><p>还有一个递推公式（可证明）：</p><script type="math/tex; mode=display">\dbinom{i}{j} = \dfrac{n-k+1}{k} \times \dbinom{i}{j-1}</script><p>但是这个可能会乘法溢出</p><details>    <summary>证明</summary>    <img src="http://latex.codecogs.com/gif.latex?\dbinom{n}{k} = \dfrac{n!}{k!(n-k)!} = \dfrac{n\cdot(n-1)\cdot(n-2)\dots\cdot1}{k\cdot(k-1)\dots\cdot1\cdot(n-k)\cdot(n-k-1)\dots\cdot1}" />    <br><br>    <img src="http://latex.codecogs.com/gif.latex?\dbinom{n}{k-1} \cdot \dfrac{n-k+1}{k} = \dfrac{n\cdot(n-1)\cdot(n-2)\dots\cdot1\cdot(n - k + 1)}{k\cdot(k-1)\dots\cdot1\cdot(n-k+1)\cdot(n-k-1)\dots\cdot1}" />    <br><br>       <img src="http://latex.codecogs.com/gif.latex? = \dbinom{n}{k}" />    <br><br>    <img src="http://latex.codecogs.com/gif.latex?\therefore" />证明完毕</details><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><ul><li><p>暴力</p><p>暴力，暴力，暴力！</p></li><li><p>预处理</p><p>用第一个递推公式先递推出来所有的数，然后对于每一次查询进行判断是否 % k == 0，时间复杂度为 $\mathcal{O}(q+tn^2)$，还是有点慢</p></li><li><p>预处理优化</p><p>我们可以想到每一判断都 % k 有点慢所以可以在预处理时 % k，判断是否等于 0 ，开过 $O2$ 95 pts，还需要优化。</p></li><li><p>前缀和+预处理</p><p>我们可以二维前缀和等于 0 的个数，然后每一次查询即可，时间复杂度变成了 $\mathcal{O}(q+t)$ ,可以过了。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> p = <span class="hljs-number">1000</span>;<br><span class="hljs-keyword">int</span> c[<span class="hljs-number">2010</span>][<span class="hljs-number">2010</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">int</span> f[<span class="hljs-number">2010</span>][<span class="hljs-number">2010</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">int</span> n,m,k,t;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">complet</span><span class="hljs-params">()</span></span>&#123;<br>c[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>c[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>c[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>; <br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">2000</span>;i++)&#123;<br>c[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>c[i][i] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;i;j++)&#123;<br>c[i][j] = (c[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + c[i<span class="hljs-number">-1</span>][j]) % k;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">2000</span>;i++)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)&#123;<br>        f[i][j] = f[i<span class="hljs-number">-1</span>][j] + f[i][j<span class="hljs-number">-1</span>] - f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];\\ 前缀和<br>        <span class="hljs-keyword">if</span>(c[i][j] == <span class="hljs-number">0</span>)f[i][j] ++;<br>        &#125;<br>        f[i][i+<span class="hljs-number">1</span>] = f[i][i];<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>cin&gt;&gt;t&gt;&gt;k;<br><span class="hljs-built_in">complet</span>();<br><span class="hljs-keyword">while</span>(t--)&#123;<br>cnt = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);<br><span class="hljs-keyword">if</span>(m &gt; n)<br>m = n;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,f[n][m]);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
      <tag>组合数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LCA问题</title>
    <link href="/2021/06/23/LCA%E9%97%AE%E9%A2%98/"/>
    <url>/2021/06/23/LCA%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="LCA"><a href="#LCA" class="headerlink" title="LCA"></a>LCA</h1><p>LCA 的问题是很经典的，我这一次就来讲解一下 LCA 的求法，就先从一道模板题入手吧</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://www.luogu.com.cn/problem/P3379">P3379 【模板】最近公共祖先（LCA）</a></p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含三个正整数 $N,M,S$ 分别表示树的结点个数、询问的个数和树根结点的序号。</p><p>接下来 $N-1$ 行每行包含两个正整数 $x, y$ 表示 $x$ 结点和 $y$ 结点之间有一条直接连接的边（数据保证可以构成树）。</p><p>接下来 $M$ 行每行包含两个正整数 $a, b$ 表示询问 $a$ 结点和 $b$ 结点的最近公共祖先。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出包含 $M$ 行，每行包含一个正整数，依次为每一个询问的结果。</p><h3 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h3><p>对于 $30\%$ 的数据，$N\leq 10，N \leq 10$。</p><p>对于 $70\%$ 的数据，$N\leq 10000，N \leq 10000$。</p><p>对于 $100\%$ 的数据，$N\leq 500000 ， N \leq 500000$</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="LCA-的一些性质"><a href="#LCA-的一些性质" class="headerlink" title="LCA 的一些性质"></a>LCA 的一些性质</h3><ul><li>两点的距离 ： $ d(u,v) = h(u) + h(v) + h(\operatorname{LCA}(u,v) )$  ，$h$ 代表某一点的深度</li><li>两点的最近公共祖先必定处在树上两点间的最短路上；</li></ul><h3 id="朴素算法"><a href="#朴素算法" class="headerlink" title="朴素算法"></a>朴素算法</h3><p>首先，我们想到最暴力的方法，先把整个树 DFS 一下，顺便将每个点的深度记录下来，将要查找的两个点中每次找深度最大的点，然后向上跳一格，最后两个点一定会相遇，相遇的点就一定是他们的 LCA 。</p><p>下面是 DFS 的代码<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> fa)</span></span>&#123;     <span class="hljs-comment">// fa 为父亲节点，u 为当前节点， dep 为节点深度</span><br>f[u] = fa;<br>dep[u] = dep[fa] + <span class="hljs-number">1</span>;   <span class="hljs-comment">// 因为是 DFS ，每个节点是从它的父亲来的，父亲与儿子的深度相差 1 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[u];i;i = nex[i])&#123;        <span class="hljs-comment">// 链式前向星</span><br><span class="hljs-keyword">int</span> v = to[i]; <br><span class="hljs-keyword">if</span>(v != fa)<br><span class="hljs-built_in">dfs</span>(v,u);<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></p><p>然后是 LCA 的核心代码 ：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(x != y)&#123;<br><span class="hljs-keyword">if</span>(dep[x] &gt;= dep[y])x = f[x];<br><span class="hljs-keyword">else</span> y = f[y];<br>&#125;<br><span class="hljs-keyword">return</span> x;<br></code></pre></div></td></tr></table></figure><p>很简单，就不详细讲了， 预处理时间复杂度是 $\mathcal{O}(n)$ ， 单次查询时间复杂度为 $\Theta(n \log n)$ （随机树上) ，时间有点慢，遇到大数据就不行了，我们需要优化 </p><h3 id="倍增-LCA"><a href="#倍增-LCA" class="headerlink" title="倍增 LCA"></a>倍增 LCA</h3><p>这里先来了解一下<strong>倍增</strong>（<a href="https://blog.csdn.net/jarjingx/article/details/8180560">更容易理解</a>），顾名思义，一倍一倍的增加，就比如一步一步跳 7 格，但是我们可以先跳 $2^2= 4$ 次，再跳 $2$ 次，最后跳 $1$ 次，原本需要跳 7 次，通过倍增只需要跳 3 次。</p><p>这里可以倍增首先基于一个推论 ：</p><ul><li><p>任意整数可以表示成若干个 2 的次幂项的和</p><p>$eg. 7 = 2^2 + 2^1 + 2^0$</p><p>$10 = 2^3 + 2^1$</p></li></ul><p>下面来讲一下倍增 LCA :</p><p>显然可以将一步一步跳变成倍增，在 DFS 时可以通过 $2^i = 2^{i-1}+2^{i-1}$ 预处理 $fa_i$ 的位置。</p><p>在查询时可以从小到大倍增（$2^0,2^1,2^2\dots$）来将 $u,v$ 跳到同一深度，在同时    跳的时候从大到小倍增（$2^i,2^{i-1}\dots 2^1,2^0$），如果两个父亲不一样，就跳，那么最后的 LCA 是 $fa_0$ </p><p>倍增 LCA 预处理时间复杂度为 $\mathcal{O}(n \log n)$ ，单次查询时间为 $\mathcal{O}(\log n)$ 。</p><p>这个时间复杂度大部分题目都是可以接受的。</p><p>代码： </p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> v)</span></span>&#123;<br>dep[u] = dep[v] + <span class="hljs-number">1</span>;<br>fa[u][<span class="hljs-number">0</span>] = v;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">19</span>;i++)<br>fa[u][i] = fa[fa[u][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;G[u].<span class="hljs-built_in">size</span>();i++)&#123;<br><span class="hljs-keyword">if</span>(G[u][i] == v)<span class="hljs-keyword">continue</span>;<br><span class="hljs-built_in">dfs</span>(G[u][i],u);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">LCA</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<br><span class="hljs-keyword">if</span>(dep[x] &gt; dep[y])<span class="hljs-built_in">swap</span>(x,y);<br><span class="hljs-keyword">int</span> tmp = dep[y] - dep[x];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;tmp;i++,tmp &gt;&gt;= <span class="hljs-number">1</span>)<br><span class="hljs-keyword">if</span>(tmp &amp; <span class="hljs-number">1</span>)<br>y = fa[y][i];<br><span class="hljs-keyword">if</span>(x == y)<span class="hljs-keyword">return</span> x;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">19</span>;i&gt;=<span class="hljs-number">0</span> &amp;&amp; x != y;i--)<br><span class="hljs-keyword">if</span>(fa[x][i] != fa[y][i])&#123;x = fa[x][i];y = fa[y][i];&#125;<br><span class="hljs-keyword">return</span> fa[x][<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LCA</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1A Theatre Square</title>
    <link href="/2021/05/16/CF1A-Theatre-Square/"/>
    <url>/2021/05/16/CF1A-Theatre-Square/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>用 $a \times a$ 的石板覆盖 $n \times m$ 的长方形广场，允许石板覆盖的区域超出广场，不允许打破石板，石板的两侧应平行于广场两侧，要求覆盖完广场所需的石板数量最少是多少。</p><h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>输入有三个数字 $n,m,a$ ($1≤n,m,a≤10^9$)</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>首先，我们看到是广场是长方形的，而石板是正方形的，<del>很容易就想到</del>可能会出现一中特殊情况：（广场的面积不足以铺一个石板），还会想到将长和宽一起除以石板边长，就是这个边所可以容纳多少个石板边长，最后再将所得的个数相乘，就是我们的答案了。<br><img src="https://z3.ax1x.com/2021/05/16/gcWxnP.png" alt="gcWxnP.png"></p><p>$AC$ 代码：<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n,m,a;<br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;a;<br>cout&lt;&lt;(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)(<span class="hljs-built_in">ceil</span>(n/(<span class="hljs-keyword">double</span>)a)*<span class="hljs-built_in">ceil</span>(m/(<span class="hljs-keyword">double</span>)a))&lt;&lt;endl;<span class="hljs-comment">//注意一定要long long 不然就会强制转换为科学计数法</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br><br></code></pre></div></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>简单题</tag>
      
      <tag>CodeForces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>P3383 【模板】线性筛素数</title>
    <link href="/2021/04/07/P3383-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E7%BA%BF%E6%80%A7%E7%AD%9B%E7%B4%A0%E6%95%B0/"/>
    <url>/2021/04/07/P3383-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E7%BA%BF%E6%80%A7%E7%AD%9B%E7%B4%A0%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://www.luogu.com.cn/problem/P3383">P3383 【模板】线性筛素数</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>如题，给定一个范围$n$，有$q$个询问，每次输出第$k$小的素数。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含两个正整数 $n,q$，分别表示查询的范围和查询的个数。</p><p>接下来$q$行每行一个正整数$k$，表示查询第$k$小的素数。  </p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出$q$行，每行一个正整数表示答案。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><p>对于 $100\%$ 的数据，$n = 10^8,1≤q≤10^6$，保证查询的素数不大于$n$。</p><h1 id="知识-题解"><a href="#知识-题解" class="headerlink" title="知识/题解"></a>知识/题解</h1><p>这题是一道筛法模版题，第一个先想到的应该是暴力枚举，但是暴力枚举时间复杂度显然太高，然后经过一番搜寻，找到了埃式筛。</p><h3 id="埃式筛"><a href="#埃式筛" class="headerlink" title="埃式筛"></a>埃式筛</h3><p>这个筛法的时间复杂度为$O(n\log\log n)$,算的上是比较优秀了。</p><blockquote><p>如果$x$是合数，那么$x$的倍数也一定是合数。  </p></blockquote><p>这个规则很容易就知道了是对的，是吧，这样我们要求100以内的数就只需将1到10以内的倍数枚举并标记，没有标记的数就是质数，这个筛法就是这个思想。<br>埃式筛的代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Eratosthenes</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++i) is_prime[i] = <span class="hljs-number">1</span>;<br>  is_prime[<span class="hljs-number">0</span>] = is_prime[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (is_prime[i]) &#123;<br>      prime[p++] = i;  <span class="hljs-comment">// prime[p]是i,后置自增运算代表当前素数数量</span><br>      <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)i * i &lt;= n)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i * i; j &lt;= n; j += i)<br>          <span class="hljs-comment">// 因为从 2 到 i - 1 的倍数我们之前筛过了，这里直接从 i</span><br>          <span class="hljs-comment">// 的倍数开始，提高了运行速度</span><br>          is_prime[j] = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 是i的倍数的均不是素数</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> p;<br>&#125;<br><br></code></pre></div></td></tr></table></figure></p><p>但是这个还是有点慢，这个数据可能会过不了，所以我们又找到了另一个更快的算法：欧拉筛（线性筛）。</p><h3 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h3><p>埃氏筛法仍有优化空间，它会将一个合数重复多次标记，所以线性筛就是来解决这个事情的。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; MAXN; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (!vis[i]) &#123;<br>      prime[cnt++] = i;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cnt; ++j) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-number">1ll</span> * i * prime[j] &gt;= MAXN) <span class="hljs-keyword">break</span>;<br>      vis[i * prime[j]] = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">if</span> (i % prime[j] == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 换言之，i 之前被 pri[j] 筛过了</span><br>        <span class="hljs-comment">// 由于 pri 里面质数是从小到大的，所以 i 乘上其他的质数的结果一定也是</span><br>        <span class="hljs-comment">// pri[j] 的倍数 它们都被筛过了，就不需要再筛了，所以这里直接 break</span><br>        <span class="hljs-comment">// 掉就好了</span><br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h1 id="本题AC代码"><a href="#本题AC代码" class="headerlink" title="本题AC代码"></a>本题AC代码</h1><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">bool</span> visited[<span class="hljs-number">100000010</span>];<br><span class="hljs-keyword">int</span> prime[<span class="hljs-number">6000010</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shai</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br><span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;i&lt;=n;i++)<br>&#123;<br><span class="hljs-keyword">if</span>(!visited[i])prime[cnt++] = i;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;cnt;j++)&#123;<br><span class="hljs-keyword">if</span>(i * prime[j] &gt; n)<br><span class="hljs-keyword">break</span>;<br>visited[i * prime[j]] = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">if</span>(i % prime[j] == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> n,m,x;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-built_in">shai</span>(n);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)<br>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,prime[x<span class="hljs-number">-1</span>]);<br>&#125;<br><span class="hljs-built_in">getchar</span>();<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
      <tag>筛法</tag>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>P1029 [NOIP2001 普及组] 最大公约数和最小公倍数</title>
    <link href="/2021/04/02/P1029-NOIP2001-%E6%99%AE%E5%8F%8A%E7%BB%84-%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E5%92%8C%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/"/>
    <url>/2021/04/02/P1029-NOIP2001-%E6%99%AE%E5%8F%8A%E7%BB%84-%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E5%92%8C%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两个正整数$x_0, y_0$，求出满足下列条件的$P, Q$的个数:  </p><ol><li>$P,Q$ 是正整数。</li><li>要求 $P, Q$ 以 $x_0$为最大公约数，以$y_0$为最小公倍数。</li></ol><p>试求：满足条件的所有可能的$P, Q$的个数。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>一行两个正整数$x_0, y_0$。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行一个数，表示求出满足条件的$P, Q$个数。    </p><h1 id="知识讲解"><a href="#知识讲解" class="headerlink" title="知识讲解"></a>知识讲解</h1><p>这一题是关于最大公约数（gcd）和最小公倍数（lcm）的，首先要算最大公约数，最好的算法是<a href="https://baike.baidu.com/item/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/1647675?fromtitle=%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95&amp;fromid=4625352">欧几里得算法</a>（辗转相除法）然而本人是个蒟蒻，所以还是要来证明一下的：</p><h3 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h3><p>设 $a=bk+c$ 则有 $c= a\bmod b$ ,设有一个数 $d \mid a~,d \mid b$（这个符号表示前者是后者的因数，能整除）,<br>则存在 $c=a-bk$ ， $\dfrac{c}{d} = \dfrac{a-b}{d}k$。<br>显而易见，$\dfrac{c}{d}$ 为整数，所以对于 $a$ 与 $b$ 的最大公约数为 $a\bmod b$ 的最大公约数（因为c为$c= a\bmod b$），<br>所以 $ \gcd(a,b) = \gcd(a,a\bmod b)$ ,而这，就是欧几里得算法的核心内容。(终于结束了)下面给出欧几里得算法的代码：    </p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;<br><span class="hljs-keyword">return</span> b==<span class="hljs-number">0</span> ? a : <span class="hljs-built_in">gcd</span>(b,a%b);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><br><br>下面我们来讲最小公倍数的算法，最小公倍数可以通过最大公约数来求.</p><h3 id="最小公倍数"><a href="#最小公倍数" class="headerlink" title="最小公倍数"></a>最小公倍数</h3><p>首先我们介绍这样一个定理——算术基本定理： </p><blockquote><p>每一个正整数都可以表示成若干整数的乘积，这种分解方式在忽略排列次序的条件下是唯一的。</p></blockquote><p>这个有一个通式 $\large x=p_1^{k_1}p_2^{k_2}p_3^{k_3}\dots b p_s^{k_s}$  </p><p>设  <script type="math/tex">\large a=p_1^{k_{a_1}}p_2^{k_{a_2}}p_3^{k_{a_3}} \dots p_s^{k_{a_s}} ,\large b=p_1^{k_{b_1}}p_2^{k_{b_2}}p_3^{k_{b_3}}\dotsb p_s^{k_{b_s}}</script>    </p><p> 可以得到，最大公约数为：  </p><script type="math/tex; mode=display">\large p_1^{\min(k_{a_1},k_{b_1})}p_2^{\min(k_{a_2},k_{b_2})}\dotsb p_s^{\min(k_{a_s},k_{b_s})}</script><p>最小公倍数为：  </p><script type="math/tex; mode=display">\large p_1^{\max(k_{a_1},k_{b_1})}p_2^{\max(k_{a_2},k_{b_2})}\dotsb p_s^{\max(k_{a_s},k_{b_s})}</script><p>将以上两个式子相乘，可以得到:</p><blockquote><p>$ \large \gcd(a,b)\times \operatorname{lcm}(a,b)=a\times b$ </p></blockquote><p>将上面的式子进行移项，就终于得到了这个重要的计算方法（呼，累死我了）： </p><blockquote><p>$\large \operatorname{lcm}(a,b) = a\times b \div \gcd(a,b)$</p></blockquote><h2 id="题解思路"><a href="#题解思路" class="headerlink" title="题解思路"></a>题解思路</h2><p>那么，这道题基本的知识都讲完了，总结一下思路：<br>首先我们可以枚举$P$，那么$Q$可通过已经给的最小公倍数和最大公约数来求，然后再算出本身这两个数的最小公倍数和最大公约数，判断它们是否相等。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> LL;<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function">LL <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123; <span class="hljs-comment">//最大公约数的算法</span><br><span class="hljs-keyword">return</span>  b==<span class="hljs-number">0</span> ? a : <span class="hljs-built_in">gcd</span>(b,a%b);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>LL n,m,ans = <span class="hljs-number">0</span>;<br>cin&gt;&gt;n&gt;&gt;m;<br><br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">sqrt</span>(m*n);i++)&#123;  <span class="hljs-comment">//枚举到sqrt个即可</span><br><span class="hljs-keyword">if</span>(n==m)&#123;<br>ans = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">int</span> j = m*n/i;  <br>LL x = <span class="hljs-number">0</span>,y = <span class="hljs-number">0</span>;<br>LL cnt = <span class="hljs-built_in">gcd</span>(i,j);<br><span class="hljs-keyword">if</span>(cnt == n &amp;&amp; i*j/cnt == m)   <span class="hljs-comment">//i*j/cnt 是算最大公约数的算法</span><br>ans += <span class="hljs-number">2</span>;<br>&#125;<br><br>cout&lt;&lt;ans&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LCM</tag>
      
      <tag>GCD</tag>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最小生成树(模板)</title>
    <link href="/2021/02/20/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-%E6%A8%A1%E6%9D%BF/"/>
    <url>/2021/02/20/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>这是个模板题<br><strong>链接</strong>:<a href="https://www.luogu.com.cn/problem/P3366">P3366 【模板】最小生成树</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>如题，给出一个无向图，求出最小生成树，如果该图不连通，则输出 orz。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含两个整数 $ N,M $ ，表示该图共有 $ N $ 个结点和 $ M $ 条无向边。<br>接下来 $ M $ 行每行包含三个整数 $ X_i,Y_i,Z_i $ ,示有一条长度为 $ Z_i $ 的无向边连接结点 $ X_i,Y_i $。 </p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>如果该图连通，则输出一个整数表示最小生成树的各边的长度之和。如果该图不连通则输出 orz。</p><h2 id="数据规模"><a href="#数据规模" class="headerlink" title="数据规模"></a>数据规模</h2><p>对于 20% 的数据，$ N≤5，M≤20 $ 。</p><p>对于 40% 的数据，$ N≤50，M≤2500 $ 。</p><p>对于 70% 的数据，$ N≤500，M≤10 $ 。</p><p>对于 100\%100% 的数据：$ 50001≤N≤5000， 1≤M≤2×10^5 $ 。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>Kruskal 算法的主要思路：</p><ol><li>先以边的权值来给边排序，从小到大  </li></ol><p><img src="https://z3.ax1x.com/2021/09/08/hb8YcQ.png" alt="dis0"></p><ol><li>然后开始由小到大遍历边，也就是一步一步的点的扩展       </li></ol><p><img src="https://z3.ax1x.com/2021/09/08/hb8J1g.png" alt="dis1"></p><ol><li>然后判断这个点的是否在已拓展的点内，如果不在就将答案加上它的边权，并且加入并查集  </li></ol><p><img src="https://z3.ax1x.com/2021/09/08/hb8G9S.png" alt="dis2"></p><p><img src="https://z3.ax1x.com/2021/09/08/hb81tf.png" alt="dis3"></p><p><img src="https://z3.ax1x.com/2021/09/08/hb83h8.png" alt="dis4"></p><p><strong>注意一下，这个是用邻接表edge写的（u，v为边的两个点，为边权），没有用领接矩阵</strong></p><p>基本上这个模板就这样了，代码如下：</p><p>​    </p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span>&#123;</span> <br><span class="hljs-keyword">int</span> u,v,w;    <span class="hljs-comment">//定义一个边的结构体，u、v为边的两个定点，w为边的边权</span><br>&#125;;<br><br><br><br>edge e[<span class="hljs-number">200005</span>];<br><span class="hljs-keyword">int</span> father[<span class="hljs-number">5005</span>];      <span class="hljs-comment">//并查集</span><br><span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> edge&amp; a,<span class="hljs-keyword">const</span> edge&amp; b)</span></span>&#123;<br><span class="hljs-keyword">return</span> a.w &lt; b.w;        <span class="hljs-comment">//sort（）的判断，以边权的由大到小的顺序来排序 </span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">found</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;          <span class="hljs-comment">//并查集的寻找父亲</span><br><span class="hljs-keyword">return</span> father[x] == x ? x : father[x] = <span class="hljs-built_in">found</span>(father[x]);        <span class="hljs-comment">//压行，并且压缩路径，这样可以将之后的查找时间变为常数级</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> n,m;<br><br>cin&gt;&gt;n&gt;&gt;m;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= m;i++)<br>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>,&amp;e[i].u,&amp;e[i].v,&amp;e[i].w);<br>&#125;<br><br><span class="hljs-built_in">sort</span>(e,e+m,cmp);    <span class="hljs-comment">//kruskal 算法的重要部分：按照边权的大小来排序</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;j&lt;=n;j++)father[j] = j;  <span class="hljs-comment">//初始化，每一个点都是一个自己的父亲</span><br><br><span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;j&lt;=m;j++)<br>&#123;<br><span class="hljs-keyword">if</span>(k == n - <span class="hljs-number">1</span>)<span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">int</span> v = e[j].v,u = e[j].u;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">found</span>(v) != <span class="hljs-built_in">found</span>(u))        <span class="hljs-comment">//如果没有这个边所在的点没有加入，就执行下面</span><br>&#123;<br>k++;   <span class="hljs-comment">//注意一点：这一句话一定要在这里写，我已经掉过坑里了</span><br>ans += e[j].w;    <span class="hljs-comment">//加入答案：最小生成树的总长</span><br><br><span class="hljs-keyword">int</span> f = <span class="hljs-built_in">found</span>(v),t = <span class="hljs-built_in">found</span>(u);<br>father[t] = f;          <span class="hljs-comment">//使这个的边的这个点加入路径</span><br>&#125;<br>&#125;<br><br><br><br><br><span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)<br><span class="hljs-keyword">if</span>(father[i] == i)<br>                cnt++;<br><br><br><span class="hljs-keyword">if</span>(cnt == <span class="hljs-number">1</span>)<br>cout&lt;&lt;ans&lt;&lt;endl;<br><span class="hljs-keyword">else</span><br>cout&lt;&lt;<span class="hljs-string">&quot;orz&quot;</span>&lt;&lt;endl;        <span class="hljs-comment">//如果有边不联通，就输出“orz”</span><br><span class="hljs-built_in">getchar</span>();<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>图论</tag>
      
      <tag>最小生成树</tag>
      
      <tag>Kruskal</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>过河卒</title>
    <link href="/2021/02/18/%E8%BF%87%E6%B2%B3%E5%8D%92/"/>
    <url>/2021/02/18/%E8%BF%87%E6%B2%B3%E5%8D%92/</url>
    
    <content type="html"><![CDATA[<h1 id="过河卒"><a href="#过河卒" class="headerlink" title="过河卒"></a>过河卒</h1><p><strong>本题链接</strong>：<a href="https://www.luogu.com.cn/problem/P1002">p1002 过河卒</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>棋盘上 $ A $ 点有一个过河卒，需要走到目标$ B $点。卒行走的规则：可以向下、或者向右。同时在棋盘上 $ C $ 点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。</p><p>棋盘用坐标表示，$ A $ 点 $ (0,0) $ 、$ B $ 点 $ (n,m) $ ，同样马的位置坐标是需要给出的。</p><p>现在要求你计算出卒从 $ A $ 点能够到达 $ B $ 点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。  </p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>一行四个正整数，分别表示 $ B $ 点坐标和马的坐标。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数，表示所有的路径条数。</p><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><p>对于100%的数据, $ 1≤n,m≤20 $ ，$ 0≤ $ 马的坐标 $ ≤20 $。</p><h1 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h1><p>我看到这题时，我就想到用递推来做这题</p><h4 id="1-根据题意并根据样例，第一步可以写出下列-（简单的）-表格："><a href="#1-根据题意并根据样例，第一步可以写出下列-（简单的）-表格：" class="headerlink" title="1. 根据题意并根据样例，第一步可以写出下列 （简单的） 表格："></a>1. 根据题意并根据样例，第一步可以写出下列 <del>（简单的）</del> 表格：</h4><div class="table-container"><table><thead><tr><th style="text-align:right"></th><th style="text-align:right">[0]</th><th style="text-align:right">[1]</th><th style="text-align:right">[2]</th><th style="text-align:right">[3]</th><th style="text-align:right">[4]</th><th style="text-align:right">[5]</th><th style="text-align:right">[6]</th></tr></thead><tbody><tr><td style="text-align:right">[0]</td><td style="text-align:right">0</td><td style="text-align:right">1</td><td style="text-align:right">1</td><td style="text-align:right">1</td><td style="text-align:right">1</td><td style="text-align:right">1</td><td style="text-align:right">1</td></tr><tr><td style="text-align:right">[1]</td><td style="text-align:right">1</td><td style="text-align:right">2</td><td style="text-align:right">3</td><td style="text-align:right">4</td><td style="text-align:right">5</td><td style="text-align:right">6</td><td style="text-align:right">7</td></tr><tr><td style="text-align:right">[2]</td><td style="text-align:right">1</td><td style="text-align:right">3</td><td style="text-align:right">6</td><td style="text-align:right">10</td><td style="text-align:right">15</td><td style="text-align:right">21</td><td style="text-align:right">28</td></tr><tr><td style="text-align:right">[3]</td><td style="text-align:right">1</td><td style="text-align:right">4</td><td style="text-align:right">10</td><td style="text-align:right">20</td><td style="text-align:right">35</td><td style="text-align:right">56</td><td style="text-align:right">84</td></tr><tr><td style="text-align:right">[4]</td><td style="text-align:right">1</td><td style="text-align:right">5</td><td style="text-align:right">15</td><td style="text-align:right">35</td><td style="text-align:right">70</td><td style="text-align:right">135</td><td style="text-align:right">219</td></tr><tr><td style="text-align:right">[5]</td><td style="text-align:right">1</td><td style="text-align:right">6</td><td style="text-align:right">21</td><td style="text-align:right">56</td><td style="text-align:right">126</td><td style="text-align:right">261</td><td style="text-align:right">370</td></tr><tr><td style="text-align:right">[6]</td><td style="text-align:right">1</td><td style="text-align:right">7</td><td style="text-align:right">28</td><td style="text-align:right">84</td><td style="text-align:right">210</td><td style="text-align:right">471</td><td style="text-align:right">841</td></tr></tbody></table></div><p><del>（显而易见）</del>，这里可以利用<a href="https://baike.baidu.com/item/%E5%8A%A0%E6%B3%95%E5%8E%9F%E7%90%86/7538330?fr=aladdin">加法原理</a>，写出<strong>递推式</strong>：</p><script type="math/tex; mode=display">f[i][j]=f[i-1][j]+f[i][j-1];(start:f[0][0]=1)</script><h4 id="2-第二步再加上马的影响"><a href="#2-第二步再加上马的影响" class="headerlink" title="2. 第二步再加上马的影响"></a>2. 第二步再加上马的影响</h4><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">[0]</th><th style="text-align:center">[1]</th><th style="text-align:center">[2]</th><th style="text-align:center">[3]</th><th style="text-align:center">[4]</th><th style="text-align:center">[5]</th><th style="text-align:center">[6]</th></tr></thead><tbody><tr><td style="text-align:center">[0]</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">[1]</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">[2]</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">[3]</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">[4]</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">0</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">[5]</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">[6]</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">3</td><td style="text-align:center">3</td><td style="text-align:center">6</td></tr></tbody></table></div><p>根据这个表格，我们可以想到先把马的控制点，也就是马能到达的地方（包括他本身的这个点，做一个预处理，之后递推的时候，如果到达马的控制点，直接跳过，继续下一个点。</p><p>基本思路就是这样，但是在测评中发现了第三个点：只有long long类型才能AC。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span>   </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> n,m,x,y;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> map[<span class="hljs-number">42</span>][<span class="hljs-number">42</span>]=&#123;&#123;<span class="hljs-number">1</span>&#125;&#125;;  \\递推开始式为f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">bool</span> horse[<span class="hljs-number">42</span>][<span class="hljs-number">42</span>];<br><span class="hljs-keyword">int</span> hx[<span class="hljs-number">9</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">-2</span>&#125;,  \\马的位移<br>hy[<span class="hljs-number">9</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;x&gt;&gt;y;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">8</span>;i++)<br>&#123;<br><span class="hljs-keyword">int</span> xx=x+hx[i],yy=y+hy[i];<br><span class="hljs-keyword">if</span> (xx&gt;n||xx&lt;<span class="hljs-number">0</span>||yy&gt;m||yy&lt;<span class="hljs-number">0</span>)<br><span class="hljs-keyword">continue</span>;<br>horse[xx][yy]=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">int</span> l=<span class="hljs-number">0</span>,k=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (!horse[<span class="hljs-number">0</span>][++k]&amp;&amp;k&lt;=m)<br>map[<span class="hljs-number">0</span>][k]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (!horse[++l][<span class="hljs-number">0</span>]&amp;&amp;l&lt;=n)<br>map[l][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br><span class="hljs-keyword">if</span> (!horse[i][j])<br>map[i][j]=map[i<span class="hljs-number">-1</span>][j]+map[i][j<span class="hljs-number">-1</span>];   \\递推式<br>cout&lt;&lt;map[n][m]&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递推</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
