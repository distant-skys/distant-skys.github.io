<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>学习线段树总结</title>
    <link href="/2021/08/22/%E5%AD%A6%E4%B9%A0%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%80%BB%E7%BB%93/"/>
    <url>/2021/08/22/%E5%AD%A6%E4%B9%A0%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>这几天在复习 qbxt 的知识，学到了线段树，就来总结一下。</p><h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><p><img src="https://z3.ax1x.com/2021/08/17/f4sLWR.png" alt=""></p><p>上面这张图显然是线段树，线段树就是一个处理区间的一个数据结构，将整个线段划分成一个树的结构，将长度不是 1 的段划分成两个子区间来求解，通过合并两个区间的信息来求解，这也是一个高效的数据结构。</p><p>总体时间复杂度为 $O(\log n)$  </p><ul><li>适用范围：区间的最小值或最大值，区间的修改，区间求和</li></ul><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>在所有操作开始之前，可以观察到一个根节点为 $p$ 的左儿子为 $p^2$ ，右儿子为  $p^2+1$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ls</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<span class="hljs-keyword">return</span> x&lt;&lt;<span class="hljs-number">1</span>;&#125;   <span class="hljs-comment">// 左儿子 left sons</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<span class="hljs-keyword">return</span> (x&lt;&lt;<span class="hljs-number">1</span>)+<span class="hljs-number">1</span>;&#125;   <span class="hljs-comment">// 右儿子 right sons</span><br></code></pre></td></tr></table></figure><h3 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h3><p>我们可以想到像树上 DFS 一样，可以一直访问儿子节点，直到儿子节点长度为 1  ，我们可以通过数据上的值去更改子节点的值，再有子节点来合并（更新）父节点的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">built</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> p)</span></span>&#123;<br>    <span class="hljs-comment">// 建树 [l,r] 为当前的区间，p 为当前的节点编号</span><br>lazy[p] = <span class="hljs-number">1</span>;<span class="hljs-comment">// lazy_tag 后面会讲到</span><br><span class="hljs-keyword">if</span>(l == r)&#123;<span class="hljs-comment">// 如果 长度为 1 </span><br>d[p] = a[l];<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">int</span> mid = l+(r-l)/<span class="hljs-number">2</span>;<span class="hljs-comment">// 递归求解</span><br><span class="hljs-built_in">built</span>(l,mid,<span class="hljs-built_in">ls</span>(p));<span class="hljs-built_in">built</span>(mid+<span class="hljs-number">1</span>,r,<span class="hljs-built_in">rs</span>(p));<br>d[p] = d[<span class="hljs-built_in">ls</span>(p)] + d[<span class="hljs-built_in">rs</span>(p)] ;  <span class="hljs-comment">// 由儿子更新父亲，合并</span><br>    <span class="hljs-comment">// 如果是求最大值，改成 d[p] = max(d[ls(p)],d[rs(p)]);最小值同样 </span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h3><p>首先，我们可以想到还是像建树一样递归求解，如果这个区间在所要求的区间上了，直接返回，如果左儿子的子区间和原答案有交集，那么就递归到相应的节点上求解。那么思路就讲好了，代码怎么写呢？下面放上几张图就了解了</p><p>设所在区间为 $[l,r]$ , 查询区间为 $[s,t]$ 。</p><p><img src="https://z3.ax1x.com/2021/08/20/fj97CQ.jpg" alt="tree"></p><p>那么根据这张图可以很显然的推出所在区间在查询区间的判断方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(s &lt;= l &amp;&amp; r &lt;= t)<br></code></pre></td></tr></table></figure><p>设中间位置为 $mid = \dfrac{(l+r)}{2}$  。</p><p><img src="https://z3.ax1x.com/2021/08/20/fjiS1J.jpg" alt=""></p><p>可以很<del>简单</del>的看出，进入左儿子的条件是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(mid &gt;= s)<br></code></pre></td></tr></table></figure><p>进入右儿子的条件是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(mid &lt; t)<br></code></pre></td></tr></table></figure><p>综上，我们可以得出查询代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">LL <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> s,<span class="hljs-keyword">int</span> t,<span class="hljs-keyword">int</span> p)</span></span>&#123;<br><span class="hljs-comment">// l,r 为当前的, s,t 为询问的</span><br><span class="hljs-keyword">if</span>(l&gt;=s &amp;&amp; r &lt;= tt)<br><span class="hljs-keyword">return</span> d[p];<br><span class="hljs-keyword">int</span> mid = l+(r-l)/<span class="hljs-number">2</span>;<br><span class="hljs-built_in">pushdown</span>(p,l,r); <br>LL sum = <span class="hljs-number">0</span>; <br><span class="hljs-keyword">if</span>(mid &gt;= s)<br>sum += <span class="hljs-built_in">query</span>(l,mid,s,t,<span class="hljs-built_in">ls</span>(p));    <span class="hljs-comment">// 如果是求最大值，就改成</span><br><span class="hljs-comment">// sum = max(quert(l,mid,s,t,ls(p)),sum);     最小值同样</span><br><span class="hljs-keyword">if</span>(tt &gt; mid)<br>sum += <span class="hljs-built_in">query</span>(mid+<span class="hljs-number">1</span>,r,s,tt,<span class="hljs-built_in">rs</span>(p));<br><span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单点修改"><a href="#单点修改" class="headerlink" title="单点修改"></a>单点修改</h3><p>在讲区间修改之前，我先来讲一下最基础的单点修改。单点修改也是递归找需要更改的点，然后再返回合并父节点的值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> f,<span class="hljs-keyword">int</span> c,<span class="hljs-keyword">int</span> p)</span></span>&#123;<br><span class="hljs-comment">// [l,r] 当前 p 节点的范围，f 是修改的点的编号， c 是修改的值</span><br><span class="hljs-keyword">if</span>(l == r)&#123;<span class="hljs-comment">// 如果递归到所达到的点了</span><br>d[p] = c;<br><span class="hljs-comment">// 如果是加上 c ，改成</span><br><span class="hljs-comment">// d[p] += c;</span><br>        <span class="hljs-comment">// 减去同理</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">int</span> mid = l + (r-l)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(mid &gt;= f)<span class="hljs-comment">// 如果所要修改的点在左儿子上，进入左儿子</span><br><span class="hljs-built_in">update</span>(l,mid,f,c,<span class="hljs-built_in">ls</span>(p));<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">update</span>(mid+<span class="hljs-number">1</span>,r,f,c,<span class="hljs-built_in">rs</span>(p));<br>d[p] = d[<span class="hljs-built_in">ls</span>(p)] + d[<span class="hljs-built_in">rs</span>(p)];<br>    <span class="hljs-comment">// 如果是求最大值，就改成</span><br>    <span class="hljs-comment">// d[p] = max(d[ls(p)] + d[rs(p)]);</span><br>    <span class="hljs-comment">// 最小值同理</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="区间修改"><a href="#区间修改" class="headerlink" title="区间修改"></a>区间修改</h3><ul><li><p>懒标记</p><p>简单来说，就是通过<strong>延迟</strong>对节点信息的更改，从而减少可能不必要的操作次数。每次执行修改时，我们通过打标记的方法表明该节点对应的区间在某一次操作中被更改，但不更新该节点的子节点的信息。实质性的修改则在下一次访问带有标记的节点时才进行。</p><pre><code>                                                                                                                                                                ----- OI-Wiki</code></pre></li></ul><p>这段话<del>深刻的阐释了</del>懒标记的作用，如果不用懒标记时间复杂度将会达到 $\mathcal{O}(n \log n)$ 有点慢，这样一来时间复杂度为 $\mathcal{O}(\log n)$ 的。</p><p>听我这样一讲有点蒙先来看代码吧：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> s,<span class="hljs-keyword">int</span> tt,<span class="hljs-keyword">int</span> c,<span class="hljs-keyword">int</span> p)</span></span>&#123;<br><span class="hljs-comment">// [l,r] 为当前的, [s,t] 为询问的</span><br><span class="hljs-keyword">if</span>(l &gt;= s &amp;&amp; r &lt;= tt)&#123;<br>t[p] += (r-l+<span class="hljs-number">1</span>)*c;lazy[p] += c  <span class="hljs-comment">//懒标记;</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">int</span> mid = l+(r-l)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(lazy[p] &amp;&amp; l!=r)&#123; <span class="hljs-comment">// 懒标记的更新</span><br>t[<span class="hljs-built_in">ls</span>(p)] += (mid-l+<span class="hljs-number">1</span>)*lazy[p];t[<span class="hljs-built_in">rs</span>(p)] += (r-mid) * lazy[p];<br>lazy[<span class="hljs-built_in">ls</span>(p)] += lazy[p];lazy[<span class="hljs-built_in">rs</span>(p)] += lazy[p];<br>lazy[p] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(mid &gt;= s)<br><span class="hljs-built_in">update</span>(l,mid,s,tt,c,<span class="hljs-built_in">ls</span>(p));<br><span class="hljs-keyword">if</span>(tt &gt; mid)<br><span class="hljs-built_in">update</span>(mid+<span class="hljs-number">1</span>,r,s,tt,c,<span class="hljs-built_in">rs</span>(p));<br>t[p] = t[<span class="hljs-built_in">ls</span>(p)] + t[<span class="hljs-built_in">rs</span>(p)];<br>&#125;<br></code></pre></td></tr></table></figure><p>举个例子吧：</p><p><img src="https://z3.ax1x.com/2021/08/22/hpaTg0.png" alt="step1"></p><p>如果我想要更改 $[9,10]$ 的每个数加上 5，我们可以先直接在这个区间上改，并给它们打上标记。</p><p><img src="https://z3.ax1x.com/2021/08/22/hpdV5d.png" alt="step2"></p><p>虽然，子节点没有更新值，但当我们要查询这两个子节点的信息时，我们会利用标记修改这两个子节点的信息，使查询的结果依旧准确。</p><p>现在，来查询一下 $[9,9]$ 的值，当递归到 $[9,10]$ 时，因为懒标记不为 0 ，所以将该区间的子区间更新并清零。</p><p><img src="https://z3.ax1x.com/2021/08/22/hpduxP.png" alt="step3"></p><p>当然为了编写的简单性，修改懒标记可以写一个单独的函数 <code>pushdown</code> 。</p><p>带乘法的查询也同理，只是新加一个乘法懒标记而已</p><h3 id="带懒标记的查询"><a href="#带懒标记的查询" class="headerlink" title="带懒标记的查询"></a>带懒标记的查询</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">LL <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> s,<span class="hljs-keyword">int</span> tt,<span class="hljs-keyword">int</span> p)</span></span>&#123;<br><span class="hljs-comment">// l,r 为当前的, s,tt 为询问的</span><br><span class="hljs-keyword">if</span>(l&gt;=s &amp;&amp; r &lt;= tt)<br><span class="hljs-keyword">return</span> t[p];<br><span class="hljs-keyword">int</span> mid = l+(r-l)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(lazy[p])&#123;<br>t[<span class="hljs-built_in">ls</span>(p)] += lazy[p] * (mid-l+<span class="hljs-number">1</span>);t[<span class="hljs-built_in">rs</span>(p)] += lazy[p] * (r-mid);<br>lazy[<span class="hljs-built_in">ls</span>(p)] += lazy[p];lazy[<span class="hljs-built_in">rs</span>(p)] += lazy[p];<br>lazy[p] = <span class="hljs-number">0</span>;<br>&#125;<br>LL sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(mid &gt;= s)<br>sum += <span class="hljs-built_in">query</span>(l,mid,s,tt,<span class="hljs-built_in">ls</span>(p));<br>    <span class="hljs-comment">// 如果是求最大值，就改成</span><br>    <span class="hljs-comment">// sum = max(quert(l,mid,s,t,ls(p)),sum);     最小值同理</span><br><span class="hljs-keyword">if</span>(tt &gt; mid)<br>sum += <span class="hljs-built_in">query</span>(mid+<span class="hljs-number">1</span>,r,s,tt,<span class="hljs-built_in">rs</span>(p));<br><span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><p>基本上有了这些操作就可以写以下几道题目：</p><ul><li><p><a href="https://www.luogu.com.cn/problem/P3372">洛谷 P3372 【模板】线段树 1</a> </p><p>这道题是个纯模板题</p></li><li><p><a href="https://www.luogu.com.cn/problem/P3373">洛谷 P3373 【模板】线段树 2</a></p><p>这道题也差不多是个模板题，只是要注意：<strong>先乘后加</strong> 懒标记</p></li><li><p><a href="https://vjudge.net/problem/HDU-1166">HDU-1166 敌兵布阵</a></p><p>单点修改的模板</p></li><li><p><a href="https://vjudge.net/problem/HDU-1754">HDU-1754 I Hate It</a></p><p>单点修改，查询最大值的模板</p></li><li><p><a href="https://vjudge.net/problem/HDU-1394">HDU-1394 Minimum Inversion Number</a> </p><p>线段树解决逆序对问题</p></li><li><p><a href="https://vjudge.net/problem/POJ-3468">POJ-3468 A Simple Problem with Integers</a></p><p>区间修改的模板题</p></li></ul><p>模板题/好题未完待续 $\dots \dots$ </p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>线段树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVA1160题解</title>
    <link href="/2021/08/22/UVA1160%E9%A2%98%E8%A7%A3/"/>
    <url>/2021/08/22/UVA1160%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ul><li>并查集</li></ul><p>简单的查找（带路经压缩）:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">return</span> x == fa[x] ? x : fa[x] = <span class="hljs-built_in">find</span>(fa[x]);<br>    <span class="hljs-comment">// fa[i] 为并查集的数组</span><br>&#125;<br></code></pre></td></tr></table></figure><p>查找（这里可以数据小完全不需要用启发式合并）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<br><span class="hljs-keyword">int</span> f = <span class="hljs-built_in">find</span>(x),t = <span class="hljs-built_in">find</span>(y);<br>    fa[f] = t;<br>&#125;<br></code></pre></td></tr></table></figure><p>查阅资料可知，只用路径压缩，不用启发式合并的平均时间复杂度为 $\mathcal{O}(\alpha (n))$ ，最坏时间复杂度为 $\mathcal{O}(m \log n)$ 。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先可以将每个元素看成点，化合物看成边，因为如果有超过 3 个物品互相形成化合物就会爆炸，所以会爆炸的条件可以看成两个是在同一祖先（在同一集合）中，（如果这两个点有一个祖先的话，合并就会有 3 个物品在一起的）。</p><p>每一次都将不在一个集合中两个数合并。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">int</span> fa[<span class="hljs-number">100010</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">return</span> x == fa[x] ? x : fa[x] = <span class="hljs-built_in">find</span>(fa[x]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> x,y;<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x) == <span class="hljs-number">1</span>)&#123;    \\ 注意输入<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">100010</span>;i++)fa[i] = i;<br><span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(x != <span class="hljs-number">-1</span>)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;y);<br><span class="hljs-keyword">int</span> f = <span class="hljs-built_in">find</span>(x),t = <span class="hljs-built_in">find</span>(y);<br><span class="hljs-keyword">if</span>(f == t)ans ++;<br><span class="hljs-keyword">else</span><br>fa[f] = t;    <span class="hljs-comment">// 如果不会爆炸，就合并</span><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>并查集</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python实现爬取UVA题库的PDF</title>
    <link href="/2021/08/09/Python%E5%AE%9E%E7%8E%B0%E7%88%AC%E5%8F%96UVA%E9%A2%98%E5%BA%93%E7%9A%84PDF/"/>
    <url>/2021/08/09/Python%E5%AE%9E%E7%8E%B0%E7%88%AC%E5%8F%96UVA%E9%A2%98%E5%BA%93%E7%9A%84PDF/</url>
    
    <content type="html"><![CDATA[<p>我在一次看洛谷日报时了解到了有一个软件可以下载 UVA 的 PDF ， 我试了一下连接不上，可能是软件的作者太久没有更新了无法下载了，我便自己写了一个 Python ,可能有些不好的地方。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> urllib3<br><span class="hljs-keyword">import</span> time<br><br>url = <span class="hljs-string">&#x27;https://uva.onlinejudge.org/external/1/p&#x27;</span><br><br>urllib3.disable_warnings()<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">download</span>(<span class="hljs-params">name,url</span>):</span><br>    response = requests.get(url,verify=<span class="hljs-literal">False</span>)  <span class="hljs-comment"># 就是这个地方不能用异步，有没有大佬知道为什么</span><br>    <span class="hljs-built_in">print</span>(response)<br>    f = <span class="hljs-built_in">open</span>(name,<span class="hljs-string">&#x27;wb&#x27;</span>)<br>    f.write(response.content)<br>    f.close()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span> :<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-----------------------------------&quot;</span>)<br>        i = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入你所需要的 UVA 题号 ： &quot;</span>))<br>        time.sleep(<span class="hljs-number">3</span>)<br>        download(<span class="hljs-built_in">str</span>(i) + <span class="hljs-string">&#x27;.pdf&#x27;</span>,url + <span class="hljs-built_in">str</span>(i) + <span class="hljs-string">&#x27;.pdf&#x27;</span>)<br></code></pre></td></tr></table></figure><p>注 ： 还会根据我的需要不定时更新</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组合数</title>
    <link href="/2021/07/05/%E7%BB%84%E5%90%88%E6%95%B0/"/>
    <url>/2021/07/05/%E7%BB%84%E5%90%88%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>这几天的竞赛期末考试中遇到了组合数的题目，就是 <a href="https://www.luogu.com.cn/problem/P2822">NOIP2016 组合数问题</a> 原题，正好现在数学学到了一点点排列组合，就来整理一下吧。</p><h2 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h2><p>就是从 $n$ 个不同元素中，抽取 $m$ 个元素的方案数。</p><p>组合数公式为：</p><script type="math/tex; mode=display">\dbinom{n}{m}= \dfrac{n!}{m! \times (n-m)!}</script><p>通过杨辉三角可得到递推公式：</p><p>$\dbinom{i}{j} = \dbinom{i-1}{j-1} + \dbinom{i-1}{j}$ </p><p>还有一个递推公式（可证明）：</p><script type="math/tex; mode=display">\dbinom{i}{j} = \dfrac{n-k+1}{k} \times \dbinom{i}{j-1}</script><p>但是这个可能会乘法溢出</p><details>    <summary>证明</summary>    <img src="http://latex.codecogs.com/gif.latex?\dbinom{n}{k} = \dfrac{n!}{k!(n-k)!} = \dfrac{n\cdot(n-1)\cdot(n-2)\dots\cdot1}{k\cdot(k-1)\dots\cdot1\cdot(n-k)\cdot(n-k-1)\dots\cdot1}" />    <br><br>    <img src="http://latex.codecogs.com/gif.latex?\dbinom{n}{k-1} \cdot \dfrac{n-k+1}{k} = \dfrac{n\cdot(n-1)\cdot(n-2)\dots\cdot1\cdot(n - k + 1)}{k\cdot(k-1)\dots\cdot1\cdot(n-k+1)\cdot(n-k-1)\dots\cdot1}" />    <br><br>       <img src="http://latex.codecogs.com/gif.latex? = \dbinom{n}{k}" />    <br><br>    <img src="http://latex.codecogs.com/gif.latex?\therefore" />证明完毕</details><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><ul><li><p>暴力</p><p>暴力，暴力，暴力！</p></li><li><p>预处理</p><p>用第一个递推公式先递推出来所有的数，然后对于每一次查询进行判断是否 % k == 0，时间复杂度为 $\mathcal{O}(q+tn^2)$，还是有点慢</p></li><li><p>预处理优化</p><p>我们可以想到每一判断都 % k 有点慢所以可以在预处理时 % k，判断是否等于 0 ，开过 $O2$ 95 pts，还需要优化。</p></li><li><p>前缀和+预处理</p><p>我们可以二维前缀和等于 0 的个数，然后每一次查询即可，时间复杂度变成了 $\mathcal{O}(q+t)$ ,可以过了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> p = <span class="hljs-number">1000</span>;<br><span class="hljs-keyword">int</span> c[<span class="hljs-number">2010</span>][<span class="hljs-number">2010</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">int</span> f[<span class="hljs-number">2010</span>][<span class="hljs-number">2010</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">int</span> n,m,k,t;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">complet</span><span class="hljs-params">()</span></span>&#123;<br>c[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>c[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>c[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>; <br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">2000</span>;i++)&#123;<br>c[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>c[i][i] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;i;j++)&#123;<br>c[i][j] = (c[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + c[i<span class="hljs-number">-1</span>][j]) % k;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">2000</span>;i++)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)&#123;<br>        f[i][j] = f[i<span class="hljs-number">-1</span>][j] + f[i][j<span class="hljs-number">-1</span>] - f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];\\ 前缀和<br>        <span class="hljs-keyword">if</span>(c[i][j] == <span class="hljs-number">0</span>)f[i][j] ++;<br>        &#125;<br>        f[i][i+<span class="hljs-number">1</span>] = f[i][i];<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>cin&gt;&gt;t&gt;&gt;k;<br><span class="hljs-built_in">complet</span>();<br><span class="hljs-keyword">while</span>(t--)&#123;<br>cnt = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);<br><span class="hljs-keyword">if</span>(m &gt; n)<br>m = n;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,f[n][m]);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
      <tag>组合数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LCA问题</title>
    <link href="/2021/06/23/LCA%E9%97%AE%E9%A2%98/"/>
    <url>/2021/06/23/LCA%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="LCA"><a href="#LCA" class="headerlink" title="LCA"></a>LCA</h1><p>LCA 的问题是很经典的，我这一次就来讲解一下 LCA 的求法，就先从一道模板题入手吧</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://www.luogu.com.cn/problem/P3379">P3379 【模板】最近公共祖先（LCA）</a></p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含三个正整数 $N,M,S$ 分别表示树的结点个数、询问的个数和树根结点的序号。</p><p>接下来 $N-1$ 行每行包含两个正整数 $x, y$ 表示 $x$ 结点和 $y$ 结点之间有一条直接连接的边（数据保证可以构成树）。</p><p>接下来 $M$ 行每行包含两个正整数 $a, b$ 表示询问 $a$ 结点和 $b$ 结点的最近公共祖先。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出包含 $M$ 行，每行包含一个正整数，依次为每一个询问的结果。</p><h3 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h3><p>对于 $30\%$ 的数据，$N\leq 10，N \leq 10$。</p><p>对于 $70\%$ 的数据，$N\leq 10000，N \leq 10000$。</p><p>对于 $100\%$ 的数据，$N\leq 500000 ， N \leq 500000$</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="LCA-的一些性质"><a href="#LCA-的一些性质" class="headerlink" title="LCA 的一些性质"></a>LCA 的一些性质</h3><ul><li>两点的距离 ： $ d(u,v) = h(u) + h(v) + h(\operatorname{LCA}(u,v) )$  ，$h$ 代表某一点的深度</li><li>两点的最近公共祖先必定处在树上两点间的最短路上；</li></ul><h3 id="朴素算法"><a href="#朴素算法" class="headerlink" title="朴素算法"></a>朴素算法</h3><p>首先，我们想到最暴力的方法，先把整个树 DFS 一下，顺便将每个点的深度记录下来，将要查找的两个点中每次找深度最大的点，然后向上跳一格，最后两个点一定会相遇，相遇的点就一定是他们的 LCA 。</p><p>下面是 DFS 的代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> fa)</span></span>&#123;     <span class="hljs-comment">// fa 为父亲节点，u 为当前节点， dep 为节点深度</span><br>f[u] = fa;<br>dep[u] = dep[fa] + <span class="hljs-number">1</span>;   <span class="hljs-comment">// 因为是 DFS ，每个节点是从它的父亲来的，父亲与儿子的深度相差 1 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[u];i;i = nex[i])&#123;        <span class="hljs-comment">// 链式前向星</span><br><span class="hljs-keyword">int</span> v = to[i]; <br><span class="hljs-keyword">if</span>(v != fa)<br><span class="hljs-built_in">dfs</span>(v,u);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>然后是 LCA 的核心代码 ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(x != y)&#123;<br><span class="hljs-keyword">if</span>(dep[x] &gt;= dep[y])x = f[x];<br><span class="hljs-keyword">else</span> y = f[y];<br>&#125;<br><span class="hljs-keyword">return</span> x;<br></code></pre></td></tr></table></figure><p>很简单，就不详细讲了<img src="https://i0.hdslb.com/bfs/emote/feb9abf68df628803ff69a244e744470c2b7e136.png@28w_28h.png" alt="">， 预处理时间复杂度是 $\mathcal{O}(n)$ ， 单次查询时间复杂度为 $\Theta(n \log n)$ （随机树上) ，时间有点慢，遇到大数据就不行了，我们需要优化 </p><h3 id="倍增-LCA"><a href="#倍增-LCA" class="headerlink" title="倍增 LCA"></a>倍增 LCA</h3><p>这里先来了解一下<strong>倍增</strong>（<a href="https://blog.csdn.net/jarjingx/article/details/8180560">更容易理解</a>），顾名思义，一倍一倍的增加，就比如一步一步跳 7 格，但是我们可以先跳 $2^2= 4$ 次，再跳 $2$ 次，最后跳 $1$ 次，原本需要跳 7 次，通过倍增只需要跳 3 次。</p><p>这里可以倍增首先基于一个推论 ：</p><ul><li><p>任意整数可以表示成若干个 2 的次幂项的和</p><p>$eg. 7 = 2^2 + 2^1 + 2^0$</p><p>$10 = 2^3 + 2^1$</p></li></ul><p>下面来讲一下倍增 LCA :</p><p>显然可以将一步一步跳变成倍增，在 DFS 时可以通过 $2^i = 2^{i-1}+2^{i-1}$ 预处理 $fa_i$ 的位置。</p><p>在查询时可以从小到大倍增（$2^0,2^1,2^2\dots$）来将 $u,v$ 跳到同一深度，在同时    跳的时候从大到小倍增（$2^i,2^{i-1}\dots 2^1,2^0$），如果两个父亲不一样，就跳，那么最后的 LCA 是 $fa_0$ </p><p>倍增 LCA 预处理时间复杂度为 $\mathcal{O}(n \log n)$ ，单次查询时间为 $\mathcal{O}(\log n)$ 。</p><p>这个时间复杂度大部分题目都是可以接受的。</p><p>代码： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> v)</span></span>&#123;<br>dep[u] = dep[v] + <span class="hljs-number">1</span>;<br>fa[u][<span class="hljs-number">0</span>] = v;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">19</span>;i++)<br>fa[u][i] = fa[fa[u][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;G[u].<span class="hljs-built_in">size</span>();i++)&#123;<br><span class="hljs-keyword">if</span>(G[u][i] == v)<span class="hljs-keyword">continue</span>;<br><span class="hljs-built_in">dfs</span>(G[u][i],u);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">LCA</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<br><span class="hljs-keyword">if</span>(dep[x] &gt; dep[y])<span class="hljs-built_in">swap</span>(x,y);<br><span class="hljs-keyword">int</span> tmp = dep[y] - dep[x];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;tmp;i++,tmp &gt;&gt;= <span class="hljs-number">1</span>)<br><span class="hljs-keyword">if</span>(tmp &amp; <span class="hljs-number">1</span>)<br>y = fa[y][i];<br><span class="hljs-keyword">if</span>(x == y)<span class="hljs-keyword">return</span> x;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">19</span>;i&gt;=<span class="hljs-number">0</span> &amp;&amp; x != y;i--)<br><span class="hljs-keyword">if</span>(fa[x][i] != fa[y][i])&#123;x = fa[x][i];y = fa[y][i];&#125;<br><span class="hljs-keyword">return</span> fa[x][<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LCA</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>P1029 [NOIP2001 普及组] 最大公约数和最小公倍数</title>
    <link href="/2021/04/02/P1029-NOIP2001-%E6%99%AE%E5%8F%8A%E7%BB%84-%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E5%92%8C%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/"/>
    <url>/2021/04/02/P1029-NOIP2001-%E6%99%AE%E5%8F%8A%E7%BB%84-%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E5%92%8C%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两个正整数$x_0, y_0$，求出满足下列条件的$P, Q$的个数:  </p><ol><li>$P,Q$ 是正整数。</li><li>要求 $P, Q$ 以 $x_0$为最大公约数，以$y_0$为最小公倍数。</li></ol><p>试求：满足条件的所有可能的$P, Q$的个数。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>一行两个正整数$x_0, y_0$。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行一个数，表示求出满足条件的$P, Q$个数。    </p><h1 id="知识讲解"><a href="#知识讲解" class="headerlink" title="知识讲解"></a>知识讲解</h1><p>这一题是关于最大公约数（gcd）和最小公倍数（lcm）的，首先要算最大公约数，最好的算法是<a href="https://baike.baidu.com/item/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/1647675?fromtitle=%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95&amp;fromid=4625352">欧几里得算法</a>（辗转相除法）然而本人是个蒟蒻，所以还是要来证明一下的：</p><h3 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h3><p>设 $a=bk+c$ 则有 $c= a\bmod b$ ,设有一个数 $d \mid a~,d \mid b$（这个符号表示前者是后者的因数，能整除）,<br>则存在 $c=a-bk$ ， $\dfrac{c}{d} = \dfrac{a-b}{d}k$。<br>显而易见，$\dfrac{c}{d}$ 为整数，所以对于 $a$ 与 $b$ 的最大公约数为 $a\bmod b$ 的最大公约数（因为c为$c= a\bmod b$），<br>所以 $ \gcd(a,b) = \gcd(a,a\bmod b)$ ,而这，就是欧几里得算法的核心内容。(终于结束了)下面给出欧几里得算法的代码：    </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;<br><span class="hljs-keyword">return</span> b==<span class="hljs-number">0</span> ? a : <span class="hljs-built_in">gcd</span>(b,a%b);<br>&#125;<br></code></pre></td></tr></table></figure><p><br><br>下面我们来讲最小公倍数的算法，最小公倍数可以通过最大公约数来求.</p><h3 id="最小公倍数"><a href="#最小公倍数" class="headerlink" title="最小公倍数"></a>最小公倍数</h3><p>首先我们介绍这样一个定理——算术基本定理： </p><blockquote><p>每一个正整数都可以表示成若干整数的乘积，这种分解方式在忽略排列次序的条件下是唯一的。</p></blockquote><p>这个有一个通式 $\large x=p_1^{k_1}p_2^{k_2}p_3^{k_3}\dots b p_s^{k_s}$  </p><p>设  <script type="math/tex">\large a=p_1^{k_{a_1}}p_2^{k_{a_2}}p_3^{k_{a_3}} \dots p_s^{k_{a_s}} ,\large b=p_1^{k_{b_1}}p_2^{k_{b_2}}p_3^{k_{b_3}}\dotsb p_s^{k_{b_s}}</script>    </p><p> 可以得到，最大公约数为：  </p><script type="math/tex; mode=display">\large p_1^{\min(k_{a_1},k_{b_1})}p_2^{\min(k_{a_2},k_{b_2})}\dotsb p_s^{\min(k_{a_s},k_{b_s})}</script><p>最小公倍数为：  </p><script type="math/tex; mode=display">\large p_1^{\max(k_{a_1},k_{b_1})}p_2^{\max(k_{a_2},k_{b_2})}\dotsb p_s^{\max(k_{a_s},k_{b_s})}</script><p>将以上两个式子相乘，可以得到:</p><blockquote><p>$ \large \gcd(a,b)\times \operatorname{lcm}(a,b)=a\times b$ </p></blockquote><p>将上面的式子进行移项，就终于得到了这个重要的计算方法（呼，累死我了）： </p><blockquote><p>$\large \operatorname{lcm}(a,b) = a\times b \div \gcd(a,b)$</p></blockquote><h2 id="题解思路"><a href="#题解思路" class="headerlink" title="题解思路"></a>题解思路</h2><p>那么，这道题基本的知识都讲完了，总结一下思路：<br>首先我们可以枚举$P$，那么$Q$可通过已经给的最小公倍数和最大公约数来求，然后再算出本身这两个数的最小公倍数和最大公约数，判断它们是否相等。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> LL;<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function">LL <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123; <span class="hljs-comment">//最大公约数的算法</span><br><span class="hljs-keyword">return</span>  b==<span class="hljs-number">0</span> ? a : <span class="hljs-built_in">gcd</span>(b,a%b);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>LL n,m,ans = <span class="hljs-number">0</span>;<br>cin&gt;&gt;n&gt;&gt;m;<br><br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">sqrt</span>(m*n);i++)&#123;  <span class="hljs-comment">//枚举到sqrt个即可</span><br><span class="hljs-keyword">if</span>(n==m)&#123;<br>ans = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">int</span> j = m*n/i;  <br>LL x = <span class="hljs-number">0</span>,y = <span class="hljs-number">0</span>;<br>LL cnt = <span class="hljs-built_in">gcd</span>(i,j);<br><span class="hljs-keyword">if</span>(cnt == n &amp;&amp; i*j/cnt == m)   <span class="hljs-comment">//i*j/cnt 是算最大公约数的算法</span><br>ans += <span class="hljs-number">2</span>;<br>&#125;<br><br>cout&lt;&lt;ans&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LCM</tag>
      
      <tag>GCD</tag>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
